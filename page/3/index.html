<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JoshuaYingWhatEgr Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoshuaYingWhatEgr Blogs">
<meta property="og:url" content="https://joshuayingwhategr.github.io/page/3/index.html">
<meta property="og:site_name" content="JoshuaYingWhatEgr Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JoshuaYingWhatEgr">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoshuaYingWhatEgr Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joshuayingwhategr.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-09-03-Fragment加载过程分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/2019-09-03-Fragment%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-09-02T16:00:00.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/2019-09-03-Fragment%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Fragment加载过程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将一个布局添加到指定的容器中我们只要在activity中添加这样一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragmentTransaction.add(R.id.fragment_container, fragment, &quot;fragment&quot;).addToBackStack(fragment.getClass().getName());</span><br></pre></td></tr></table></figure>
<p>这样就将fragment的布局载入到了指定的container布局中。</p>
<p>##源代码分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction fragmentTransaction &#x3D; supportFragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>
<p>通过获取fragment事务得到BackStackRecord的对象，fragment的所有add，replce，show，hide等操作都是通过BackStackRecord执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public FragmentTransaction beginTransaction() &#123;</span><br><span class="line">        return new BackStackRecord(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着执行到add方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) &#123;</span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将容器ID，fragment，以及add的标记传入了doAddOp方法中，同时doAddOp方法写入了一个OP_ADD的标记.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; </span><br><span class="line">        fragment.mFragmentManager &#x3D; mManager; </span><br><span class="line">  if (tag !&#x3D; null) &#123; </span><br><span class="line">            if (fragment.mTag !&#x3D; null &amp;&amp; !tag.equals(fragment.mTag)) &#123; </span><br><span class="line">                throw new IllegalStateException(&quot;Can&#39;t change tag of fragment &quot; </span><br><span class="line">                        + fragment + &quot;: was &quot; + fragment.mTag </span><br><span class="line">                        + &quot; now &quot; + tag); </span><br><span class="line">            &#125; </span><br><span class="line">            fragment.mTag &#x3D; tag; </span><br><span class="line">        &#125; </span><br><span class="line"> if (containerViewId !&#x3D; 0) &#123; </span><br><span class="line">            if (fragment.mFragmentId !&#x3D; 0 &amp;&amp; fragment.mFragmentId !&#x3D; containerViewId) &#123; </span><br><span class="line">                throw new IllegalStateException(&quot;Can&#39;t change container ID of fragment &quot; </span><br><span class="line">                        + fragment + &quot;: was &quot; + fragment.mFragmentId </span><br><span class="line">                        + &quot; now &quot; + containerViewId); </span><br><span class="line">            &#125; </span><br><span class="line">            fragment.mContainerId &#x3D; fragment.mFragmentId &#x3D; containerViewId; </span><br><span class="line">        &#125; </span><br><span class="line"> Op op &#x3D; new Op(); </span><br><span class="line">        op.cmd &#x3D; opcmd; </span><br><span class="line">        op.fragment &#x3D; fragment; </span><br><span class="line">        addOp(op); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>设置fragment的tag，容器的id，以及创建一个Op类的对象(Op类内部维护的是一个栈),同时将fragment和OP_ADD赋值给op成员变量。接着执行addOp(op)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void addOp(Op op) &#123; </span><br><span class="line">        if (mHead &#x3D;&#x3D; null) &#123; </span><br><span class="line">            mHead &#x3D; mTail &#x3D; op; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            op.prev &#x3D; mTail; </span><br><span class="line">            mTail.next &#x3D; op; </span><br><span class="line">            mTail &#x3D; op; </span><br><span class="line">        &#125; </span><br><span class="line">        op.enterAnim &#x3D; mEnterAnim; </span><br><span class="line">        op.exitAnim &#x3D; mExitAnim; </span><br><span class="line">        op.popEnterAnim &#x3D; mPopEnterAnim; </span><br><span class="line">        op.popExitAnim &#x3D; mPopExitAnim; </span><br><span class="line">        mNumOp++; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里将设置的动画加入op中。</p>
<p>接下来执行commit方法,commit方法也是在BackStackRecord类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int commit() &#123; </span><br><span class="line">        return commitInternal(false); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int commitInternal(boolean allowStateLoss) &#123; </span><br><span class="line">        if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;); </span><br><span class="line">        if (FragmentManagerImpl.DEBUG) Log.v(TAG, &quot;Commit: &quot; + this); </span><br><span class="line">        mCommitted &#x3D; true; </span><br><span class="line">        if (mAddToBackStack) &#123; </span><br><span class="line">            mIndex &#x3D; mManager.allocBackStackIndex(this); </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            mIndex &#x3D; -1; </span><br><span class="line">        &#125; </span><br><span class="line">        mManager.enqueueAction(this, allowStateLoss); </span><br><span class="line">        return mIndex; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这个类只如果设置了addToBackStack回退栈方法这里的mAddToBackStack就会被执行到。<br>mManager是FragmentManagerImpl的对象，最终调用了enqueueAction方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123; </span><br><span class="line">        if (!allowStateLoss) &#123; </span><br><span class="line">            checkStateLoss(); </span><br><span class="line">        &#125; </span><br><span class="line">        synchronized (this) &#123; </span><br><span class="line">            if (mActivity &#x3D;&#x3D; null) &#123; </span><br><span class="line">                throw new IllegalStateException(&quot;Activity has been destroyed&quot;); </span><br><span class="line">            &#125; </span><br><span class="line">            if (mPendingActions &#x3D;&#x3D; null) &#123; </span><br><span class="line">                mPendingActions &#x3D; new ArrayList&lt;Runnable&gt;(); </span><br><span class="line">            &#125; </span><br><span class="line">            mPendingActions.add(action); </span><br><span class="line">            if (mPendingActions.size() &#x3D;&#x3D; 1) &#123; </span><br><span class="line">                mActivity.mHandler.removeCallbacks(mExecCommit); </span><br><span class="line">                mActivity.mHandler.post(mExecCommit); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其中allowStateLoss为true是不执行checkStateLoss，如果为false就执行checkStateLoss。这对应着我们选择commit(false)还是commitAllowingStateLoss(true).接着是一个同步方法将BackStackRecord方法装入mPendingActions中，最后在主线程中执行了mExecCommit。在mExecCommit的runnable方法中调用了execPendingActions。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public boolean execPendingActions() &#123; </span><br><span class="line">        if (mExecutingActions) &#123; </span><br><span class="line">            throw new IllegalStateException(&quot;Recursive entry to executePendingTransactions&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">         </span><br><span class="line">        if (Looper.myLooper() !&#x3D; mActivity.mHandler.getLooper()) &#123; </span><br><span class="line">            throw new IllegalStateException(&quot;Must be called from main thread of process&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">  boolean didSomething &#x3D; false;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">            int numActions; </span><br><span class="line">             </span><br><span class="line">            synchronized (this) &#123; </span><br><span class="line">                if (mPendingActions &#x3D;&#x3D; null || mPendingActions.size() &#x3D;&#x3D; 0) &#123; </span><br><span class="line">                    break; </span><br><span class="line">                &#125; </span><br><span class="line">                 </span><br><span class="line">                numActions &#x3D; mPendingActions.size(); </span><br><span class="line">                if (mTmpActions &#x3D;&#x3D; null || mTmpActions.length &lt; numActions) &#123; </span><br><span class="line">                    mTmpActions &#x3D; new Runnable[numActions]; </span><br><span class="line">                &#125; </span><br><span class="line">                mPendingActions.toArray(mTmpActions); </span><br><span class="line">                mPendingActions.clear(); </span><br><span class="line">                mActivity.mHandler.removeCallbacks(mExecCommit); </span><br><span class="line">            &#125; </span><br><span class="line">             </span><br><span class="line">            mExecutingActions &#x3D; true; </span><br><span class="line">            for (int i&#x3D;0; i&lt;numActions; i++) &#123; </span><br><span class="line">                mTmpActions[i].run(); </span><br><span class="line">                mTmpActions[i] &#x3D; null; </span><br><span class="line">            &#125; </span><br><span class="line">            mExecutingActions &#x3D; false; </span><br><span class="line">            didSomething &#x3D; true; </span><br><span class="line">        &#125; </span><br><span class="line"> if (mHavePendingDeferredStart) &#123;</span><br><span class="line">            boolean loadersRunning &#x3D; false; </span><br><span class="line">            for (int i&#x3D;0; i&lt;mActive.size(); i++) &#123; </span><br><span class="line">                Fragment f &#x3D; mActive.get(i); </span><br><span class="line">                if (f !&#x3D; null &amp;&amp; f.mLoaderManager !&#x3D; null) &#123; </span><br><span class="line">                    loadersRunning |&#x3D; f.mLoaderManager.hasRunningLoaders(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            if (!loadersRunning) &#123; </span><br><span class="line">                mHavePendingDeferredStart &#x3D; false; </span><br><span class="line">                startPendingDeferredFragments(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return didSomething; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个里面用了一个while(true)循环对象对mPendingActions进行操作 mPendingActions中还是一个BackStackRecord对象，然后执行mPendingActions中的run方法，最终还是回到了BackStackRecord类中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        if (FragmentManagerImpl.DEBUG) Log.v(TAG, &quot;Run: &quot; + this);</span><br><span class="line">        if (mAddToBackStack) &#123;</span><br><span class="line">            if (mIndex &lt; 0) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;addToBackStack() called after commit()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bumpBackStackNesting(1);</span><br><span class="line">        Op op &#x3D; mHead;</span><br><span class="line">        while (op !&#x3D; null) &#123;</span><br><span class="line">            switch (op.cmd) &#123;</span><br><span class="line">                case OP_ADD: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.enterAnim;</span><br><span class="line">                    mManager.addFragment(f, false);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_REPLACE: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    if (mManager.mAdded !&#x3D; null) &#123;</span><br><span class="line">                        for (int i&#x3D;0; i&lt;mManager.mAdded.size(); i++) &#123;</span><br><span class="line">                            Fragment old &#x3D; mManager.mAdded.get(i);</span><br><span class="line">                            if (FragmentManagerImpl.DEBUG) Log.v(TAG,</span><br><span class="line">                                    &quot;OP_REPLACE: adding&#x3D;&quot; + f + &quot; old&#x3D;&quot; + old);</span><br><span class="line">                            if (f &#x3D;&#x3D; null || old.mContainerId &#x3D;&#x3D; f.mContainerId) &#123;</span><br><span class="line">                                if (old &#x3D;&#x3D; f) &#123;</span><br><span class="line">                                    op.fragment &#x3D; f &#x3D; null;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    if (op.removed &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                        op.removed &#x3D; new ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    op.removed.add(old);</span><br><span class="line">                                    old.mNextAnim &#x3D; op.exitAnim;</span><br><span class="line">                                    if (mAddToBackStack) &#123;</span><br><span class="line">                                        old.mBackStackNesting +&#x3D; 1;</span><br><span class="line">                                        if (FragmentManagerImpl.DEBUG) Log.v(TAG, &quot;Bump nesting of &quot;</span><br><span class="line">                                                + old + &quot; to &quot; + old.mBackStackNesting);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    mManager.removeFragment(old, mTransition, mTransitionStyle);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f !&#x3D; null) &#123;</span><br><span class="line">                        f.mNextAnim &#x3D; op.enterAnim;</span><br><span class="line">                        mManager.addFragment(f, false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_REMOVE: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.exitAnim;</span><br><span class="line">                    mManager.removeFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_HIDE: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.exitAnim;</span><br><span class="line">                    mManager.hideFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_SHOW: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.enterAnim;</span><br><span class="line">                    mManager.showFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_DETACH: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.exitAnim;</span><br><span class="line">                    mManager.detachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case OP_ATTACH: &#123;</span><br><span class="line">                    Fragment f &#x3D; op.fragment;</span><br><span class="line">                    f.mNextAnim &#x3D; op.enterAnim;</span><br><span class="line">                    mManager.attachFragment(f, mTransition, mTransitionStyle);</span><br><span class="line">                &#125; break;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Unknown cmd: &quot; + op.cmd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            op &#x3D; op.next;</span><br><span class="line">        &#125;</span><br><span class="line">        mManager.moveToState(mManager.mCurState, mTransition,</span><br><span class="line">                mTransitionStyle, true);</span><br><span class="line">        if (mAddToBackStack) &#123;</span><br><span class="line">            mManager.addBackStackState(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个里面也是一个while(true)的循环判断，最终不断的轮训op类，每个op类的实例都包装了一个Fragment实例，方法内部对不同的实例用switch执行，由于上面的代码中我们用了add来添加一个Fragment，op的cmd标记设置为了OP_ADD因此接下来会执行到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fragment f &#x3D; op.fragment;</span><br><span class="line">f.mNextAnim &#x3D; op.enterAnim;</span><br><span class="line">mManager.addFragment(f, false);</span><br></pre></td></tr></table></figure>
<p>这里通过FragmentManager的管理类addFragment，将fragment加入一个叫做mAdded的成员变量中，类型是ArrayList。接着执行FragmentManager的moveToState方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(int newState, int transit, int transitStyle, boolean always) &#123;</span><br><span class="line">        if (mActivity &#x3D;&#x3D; null &amp;&amp; newState !&#x3D; Fragment.INITIALIZING) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        if (!always &amp;&amp; mCurState &#x3D;&#x3D; newState) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        mCurState &#x3D; newState;</span><br><span class="line">        if (mActive !&#x3D; null) &#123;</span><br><span class="line">            boolean loadersRunning &#x3D; false;</span><br><span class="line">            for (int i&#x3D;0; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">                Fragment f &#x3D; mActive.get(i);</span><br><span class="line">                if (f !&#x3D; null) &#123;</span><br><span class="line">                    moveToState(f, newState, transit, transitStyle, false);</span><br><span class="line">                    if (f.mLoaderManager !&#x3D; null) &#123;</span><br><span class="line">                        loadersRunning |&#x3D; f.mLoaderManager.hasRunningLoaders();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!loadersRunning) &#123;</span><br><span class="line">                startPendingDeferredFragments();</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNeedMenuInvalidate &amp;&amp; mActivity !&#x3D; null &amp;&amp; mCurState &#x3D;&#x3D; Fragment.RESUMED) &#123;</span><br><span class="line">                mActivity.invalidateOptionsMenu();</span><br><span class="line">                mNeedMenuInvalidate &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在当前方法中通过for循环获取fragment，然后调用5个参数的moveToState。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">void moveToState(Fragment f, int newState, int transit, int transitionStyle,</span><br><span class="line">            boolean keepActive) &#123;</span><br><span class="line">        &#x2F;&#x2F; Fragments that are not currently added will sit in the onCreate() state.</span><br><span class="line">        if ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">            newState &#x3D; Fragment.CREATED;</span><br><span class="line">        &#125;</span><br><span class="line">        if (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">            &#x2F;&#x2F; While removing a fragment, we can&#39;t change it to a higher state.</span><br><span class="line">            newState &#x3D; f.mState;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Defer start if requested; don&#39;t allow it to move to STARTED or higher</span><br><span class="line">        &#x2F;&#x2F; if it&#39;s not already started.</span><br><span class="line">        if (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">            newState &#x3D; Fragment.STOPPED;</span><br><span class="line">        &#125;</span><br><span class="line">        if (f.mState &lt; newState) &#123;</span><br><span class="line">            &#x2F;&#x2F; For fragments that are created from a layout, when restoring from</span><br><span class="line">            &#x2F;&#x2F; state we don&#39;t want to allow them to be created until they are</span><br><span class="line">            &#x2F;&#x2F; being reloaded from the layout.</span><br><span class="line">            if (f.mFromLayout &amp;&amp; !f.mInLayout) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (f.mAnimatingAway !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; The fragment is currently being animated... but! Now we</span><br><span class="line">                &#x2F;&#x2F; want to move our state back up. Give up on waiting for the</span><br><span class="line">                &#x2F;&#x2F; animation, move to whatever the final state should be once</span><br><span class="line">                &#x2F;&#x2F; the animation is done, and then we can proceed from there.</span><br><span class="line">                f.mAnimatingAway &#x3D; null;</span><br><span class="line">                moveToState(f, f.mStateAfterAnimating, 0, 0, true);</span><br><span class="line">            &#125;</span><br><span class="line">            switch (f.mState) &#123;</span><br><span class="line">                case Fragment.INITIALIZING:</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;moveto CREATED: &quot; + f);</span><br><span class="line">                    if (f.mSavedFragmentState !&#x3D; null) &#123;</span><br><span class="line">                        f.mSavedViewState &#x3D; f.mSavedFragmentState.getSparseParcelableArray(</span><br><span class="line">                                FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">                        f.mTarget &#x3D; getFragment(f.mSavedFragmentState,</span><br><span class="line">                                FragmentManagerImpl.TARGET_STATE_TAG);</span><br><span class="line">                        if (f.mTarget !&#x3D; null) &#123;</span><br><span class="line">                            f.mTargetRequestCode &#x3D; f.mSavedFragmentState.getInt(</span><br><span class="line">                                    FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mUserVisibleHint &#x3D; f.mSavedFragmentState.getBoolean(</span><br><span class="line">                                FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);</span><br><span class="line">                        if (!f.mUserVisibleHint) &#123;</span><br><span class="line">                            f.mDeferStart &#x3D; true;</span><br><span class="line">                            if (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                                newState &#x3D; Fragment.STOPPED;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mActivity &#x3D; mActivity;</span><br><span class="line">                    f.mParentFragment &#x3D; mParent;</span><br><span class="line">                    f.mFragmentManager &#x3D; mParent !&#x3D; null</span><br><span class="line">                            ? mParent.mChildFragmentManager : mActivity.mFragments;</span><br><span class="line">                    f.mCalled &#x3D; false;</span><br><span class="line">                    f.onAttach(mActivity);</span><br><span class="line">                    if (!f.mCalled) &#123;</span><br><span class="line">                        throw new SuperNotCalledException(&quot;Fragment &quot; + f</span><br><span class="line">                                + &quot; did not call through to super.onAttach()&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (f.mParentFragment &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        mActivity.onAttachFragment(f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!f.mRetaining) &#123;</span><br><span class="line">                        f.performCreate(f.mSavedFragmentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mRetaining &#x3D; false;</span><br><span class="line">                    if (f.mFromLayout) &#123;</span><br><span class="line">                        &#x2F;&#x2F; For fragments that are part of the content view</span><br><span class="line">                        &#x2F;&#x2F; layout, we need to instantiate the view immediately</span><br><span class="line">                        &#x2F;&#x2F; and the inflater will take care of adding it.</span><br><span class="line">                        f.mView &#x3D; f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                                f.mSavedFragmentState), null, f.mSavedFragmentState);</span><br><span class="line">                        if (f.mView !&#x3D; null) &#123;</span><br><span class="line">                            f.mInnerView &#x3D; f.mView;</span><br><span class="line">                            f.mView &#x3D; NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">                            if (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            f.mInnerView &#x3D; null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.CREATED:</span><br><span class="line">                    if (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;moveto ACTIVITY_CREATED: &quot; + f);</span><br><span class="line">                        if (!f.mFromLayout) &#123;</span><br><span class="line">                            ViewGroup container &#x3D; null;</span><br><span class="line">                            if (f.mContainerId !&#x3D; 0) &#123;</span><br><span class="line">                                container &#x3D; (ViewGroup)mContainer.findViewById(f.mContainerId);</span><br><span class="line">                                if (container &#x3D;&#x3D; null &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                                    throwException(new IllegalArgumentException(</span><br><span class="line">                                            &quot;No view found for id 0x&quot;</span><br><span class="line">                                            + Integer.toHexString(f.mContainerId) + &quot; (&quot;</span><br><span class="line">                                            + f.getResources().getResourceName(f.mContainerId)</span><br><span class="line">                                            + &quot;) for fragment &quot; + f));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.mContainer &#x3D; container;</span><br><span class="line">                            f.mView &#x3D; f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                                    f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">                            if (f.mView !&#x3D; null) &#123;</span><br><span class="line">                                f.mInnerView &#x3D; f.mView;</span><br><span class="line">                                f.mView &#x3D; NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">                                if (container !&#x3D; null) &#123;</span><br><span class="line">                                    Animation anim &#x3D; loadAnimation(f, transit, true,</span><br><span class="line">                                            transitionStyle);</span><br><span class="line">                                    if (anim !&#x3D; null) &#123;</span><br><span class="line">                                        f.mView.startAnimation(anim);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    container.addView(f.mView);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                                f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                f.mInnerView &#x3D; null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">                        if (f.mView !&#x3D; null) &#123;</span><br><span class="line">                            f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mSavedFragmentState &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.ACTIVITY_CREATED:</span><br><span class="line">                case Fragment.STOPPED:</span><br><span class="line">                    if (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;moveto STARTED: &quot; + f);</span><br><span class="line">                        f.performStart();</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.STARTED:</span><br><span class="line">                    if (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;moveto RESUMED: &quot; + f);</span><br><span class="line">                        f.mResumed &#x3D; true;</span><br><span class="line">                        f.performResume();</span><br><span class="line">                        f.mSavedFragmentState &#x3D; null;</span><br><span class="line">                        f.mSavedViewState &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (f.mState &gt; newState) &#123;</span><br><span class="line">            switch (f.mState) &#123;</span><br><span class="line">                case Fragment.RESUMED:</span><br><span class="line">                    if (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;movefrom RESUMED: &quot; + f);</span><br><span class="line">                        f.performPause();</span><br><span class="line">                        f.mResumed &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.STARTED:</span><br><span class="line">                    if (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;movefrom STARTED: &quot; + f);</span><br><span class="line">                        f.performStop();</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.STOPPED:</span><br><span class="line">                    if (newState &lt; Fragment.STOPPED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;movefrom STOPPED: &quot; + f);</span><br><span class="line">                        f.performReallyStop();</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.ACTIVITY_CREATED:</span><br><span class="line">                    if (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;movefrom ACTIVITY_CREATED: &quot; + f);</span><br><span class="line">                        if (f.mView !&#x3D; null) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Need to save the current view state if not</span><br><span class="line">                            &#x2F;&#x2F; done already.</span><br><span class="line">                            if (!mActivity.isFinishing() &amp;&amp; f.mSavedViewState &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                saveFragmentViewState(f);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.performDestroyView();</span><br><span class="line">                        if (f.mView !&#x3D; null &amp;&amp; f.mContainer !&#x3D; null) &#123;</span><br><span class="line">                            Animation anim &#x3D; null;</span><br><span class="line">                            if (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed) &#123;</span><br><span class="line">                                anim &#x3D; loadAnimation(f, transit, false,</span><br><span class="line">                                        transitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (anim !&#x3D; null) &#123;</span><br><span class="line">                                final Fragment fragment &#x3D; f;</span><br><span class="line">                                f.mAnimatingAway &#x3D; f.mView;</span><br><span class="line">                                f.mStateAfterAnimating &#x3D; newState;</span><br><span class="line">                                anim.setAnimationListener(new AnimationListener() &#123;</span><br><span class="line">                                    @Override</span><br><span class="line">                                    public void onAnimationEnd(Animation animation) &#123;</span><br><span class="line">                                        if (fragment.mAnimatingAway !&#x3D; null) &#123;</span><br><span class="line">                                            fragment.mAnimatingAway &#x3D; null;</span><br><span class="line">                                            moveToState(fragment, fragment.mStateAfterAnimating,</span><br><span class="line">                                                    0, 0, false);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    @Override</span><br><span class="line">                                    public void onAnimationRepeat(Animation animation) &#123;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    @Override</span><br><span class="line">                                    public void onAnimationStart(Animation animation) &#123;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                                f.mView.startAnimation(anim);</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.mContainer.removeView(f.mView);</span><br><span class="line">                        &#125;</span><br><span class="line">                        f.mContainer &#x3D; null;</span><br><span class="line">                        f.mView &#x3D; null;</span><br><span class="line">                        f.mInnerView &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Fragment.CREATED:</span><br><span class="line">                    if (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                        if (mDestroyed) &#123;</span><br><span class="line">                            if (f.mAnimatingAway !&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; The fragment&#39;s containing activity is</span><br><span class="line">                                &#x2F;&#x2F; being destroyed, but this fragment is</span><br><span class="line">                                &#x2F;&#x2F; currently animating away. Stop the</span><br><span class="line">                                &#x2F;&#x2F; animation right now -- it is not needed,</span><br><span class="line">                                &#x2F;&#x2F; and we can&#39;t wait any more on destroying</span><br><span class="line">                                &#x2F;&#x2F; the fragment.</span><br><span class="line">                                View v &#x3D; f.mAnimatingAway;</span><br><span class="line">                                f.mAnimatingAway &#x3D; null;</span><br><span class="line">                                v.clearAnimation();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (f.mAnimatingAway !&#x3D; null) &#123;</span><br><span class="line">                            &#x2F;&#x2F; We are waiting for the fragment&#39;s view to finish</span><br><span class="line">                            &#x2F;&#x2F; animating away. Just make a note of the state</span><br><span class="line">                            &#x2F;&#x2F; the fragment now should move to once the animation</span><br><span class="line">                            &#x2F;&#x2F; is done.</span><br><span class="line">                            f.mStateAfterAnimating &#x3D; newState;</span><br><span class="line">                            newState &#x3D; Fragment.CREATED;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            if (DEBUG) Log.v(TAG, &quot;movefrom CREATED: &quot; + f);</span><br><span class="line">                            if (!f.mRetaining) &#123;</span><br><span class="line">                                f.performDestroy();</span><br><span class="line">                            &#125;</span><br><span class="line">                            f.mCalled &#x3D; false;</span><br><span class="line">                            f.onDetach();</span><br><span class="line">                            if (!f.mCalled) &#123;</span><br><span class="line">                                throw new SuperNotCalledException(&quot;Fragment &quot; + f</span><br><span class="line">                                        + &quot; did not call through to super.onDetach()&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (!keepActive) &#123;</span><br><span class="line">                                if (!f.mRetaining) &#123;</span><br><span class="line">                                    makeInactive(f);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    f.mActivity &#x3D; null;</span><br><span class="line">                                    f.mFragmentManager &#x3D; null;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        f.mState &#x3D; newState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中会依次执行INITIALIZING，CREATED，ACTIVITY_CREATED代码片段，最终在CREATED语句中通过container.addView(f.mView);加载fragment布局。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/09/03/2019-09-03-Fragment%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" data-id="ck8cxir2v00167g9k044c4dk1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-08-28-Java中的自动装箱和拆箱" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/28/2019-08-28-Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/" class="article-date">
  <time datetime="2019-08-27T16:00:00.000Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/28/2019-08-28-Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/">Java中的自动装箱和拆箱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#为什么要有自动装箱和拆箱</p>
<ol>
<li>将一个数值转换成一个类，可以使这个类有多种可以调用的方法。</li>
<li>基本类型的数据不是对象需要装箱才能和其他Object类型的子类共用同一个接口。</li>
</ol>
<p>#什么是装箱拆箱<br>从JavaSE5就提供了自动装箱的操作，如果生成一个数值为10的Integer对象只要这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer value &#x3D; 10;</span><br></pre></td></tr></table></figure>
<p>这个过程就会自动的将10这个int类型的数据转换成Object对象类型.<br>现在如果要将value这个Object类型的数据转换成int类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; value</span><br></pre></td></tr></table></figure>
<p>这样就将value转换成了int类型，完成了自动拆箱的操作.<br>基本类型包装成Object类型有这些</p>
<ol>
<li>int—&gt;Integer</li>
<li>byte–&gt;Byte</li>
<li>short-&gt;Short</li>
<li>char–&gt;Character</li>
<li>long–&gt;Long</li>
<li>double-&gt;Double</li>
<li>float–&gt;Float</li>
<li>boolean-&gt;Boolean</li>
</ol>
<p>#常见问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 &#x3D; 100;</span><br><span class="line">        Integer i2 &#x3D; 100;</span><br><span class="line">        Integer i3 &#x3D; 200;</span><br><span class="line">        Integer i4 &#x3D; 200;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1&#x3D;&#x3D;i2);</span><br><span class="line">        System.out.println(i3&#x3D;&#x3D;i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段程序输出怎样的结果?第一段代码输出 true;第二段代码输出 false;这段代码当执行到Integer i1 = 100时,内部执行的是Integer i1 = Integer.valueOf(100).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中可以看出当我们传入的值在IntegerCache.low和IntegerCache.high之间(也就是-127～128)就直接从缓存中返回数据,否则就重新创建一个对象，执行new Integer(i)。<br>因此上面的代码中100在-127～128之间，但是200不在这个区间就会重新创建对象，由于不是同一个对象了所以返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Double i1 &#x3D; 100.0;</span><br><span class="line">        Double i2 &#x3D; 100.0;</span><br><span class="line">        Double i3 &#x3D; 200.0;</span><br><span class="line">        Double i4 &#x3D; 200.0;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1&#x3D;&#x3D;i2);</span><br><span class="line">        System.out.println(i3&#x3D;&#x3D;i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码都会输出false。从下面的源码可以看出都会new一个double类型的数据；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Double valueOf(double d) &#123;</span><br><span class="line">        return new Double(d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean i1 &#x3D; false;</span><br><span class="line">        Boolean i2 &#x3D; false;</span><br><span class="line">        Boolean i3 &#x3D; true;</span><br><span class="line">        Boolean i4 &#x3D; true;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1&#x3D;&#x3D;i2);</span><br><span class="line">        System.out.println(i3&#x3D;&#x3D;i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码都会输出true。我们查看一下源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而其中的TRUE和FALSE,他们都是一个静态的常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The &#123;@code Boolean&#125; object corresponding to the primitive</span><br><span class="line"> * value &#123;@code true&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final Boolean TRUE &#x3D; new Boolean(true);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The &#123;@code Boolean&#125; object corresponding to the primitive</span><br><span class="line"> * value &#123;@code false&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final Boolean FALSE &#x3D; new Boolean(false);</span><br></pre></td></tr></table></figure>

<p>参考文章:<br><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3780005.html</a>;<br><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/</a>    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/08/28/2019-08-28-Java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/" data-id="ck8cxir2u00137g9kg7c17xo2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-7-17-理解LayoutInflate.inflater的三个参数含义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/2019-7-17-%E7%90%86%E8%A7%A3LayoutInflate.inflater%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/" class="article-date">
  <time datetime="2019-07-16T16:00:00.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/2019-7-17-%E7%90%86%E8%A7%A3LayoutInflate.inflater%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/">理解LayoutInflate.inflater的三个参数含义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有些时候我们可以通过代码来添加一个布局到我们的应用中,这个时候就需要用到LayoutInflate.inflate了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure>
<ol>
<li>resource:这个参数表示要添加的布局结构；</li>
<li>root:表示要添加的布局结构需要依赖的根布局;</li>
<li>attachToRoot:表示布局是否要添加到根布局。</li>
</ol>
<h2 id="root-null-attachToRoot-true"><a href="#root-null-attachToRoot-true" class="headerlink" title="root != null,attachToRoot = true"></a>root != null,attachToRoot = true</h2><p>当root不为空,attachToRoot为true时表示将resource布局添加到root中,resource的各个节点都是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout ll &#x3D; (LinearLayout) findViewById(R.id.ll);</span><br><span class="line">LayoutInflater inflater &#x3D; LayoutInflater.from(this);</span><br><span class="line">View view &#x3D; inflater.inflate(R.layout.linearlayout, ll, true);</span><br></pre></td></tr></table></figure>
<p>如果这个时候我们添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll.addView(view);</span><br></pre></td></tr></table></figure>
<p>那么这个时候就会报重复添加的错误.</p>
<h2 id="root-null-attachToRoot-false"><a href="#root-null-attachToRoot-false" class="headerlink" title="root != null,attachToRoot = false"></a>root != null,attachToRoot = false</h2><p>当root不为空,attachToRoot为false时表示将resource布局不添加到root中。这种情况表示我们想要resource的各个节点有效但是又不想将这个resource和root关联，这个时候如果需要添加到root中需要手动调用addview。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout ll &#x3D; (LinearLayout) findViewById(R.id.ll);</span><br><span class="line">LayoutInflater inflater &#x3D; LayoutInflater.from(this);</span><br><span class="line">View view &#x3D; inflater.inflate(R.layout.linearlayout, ll, true);</span><br><span class="line">ll.addView(view);&#x2F;&#x2F;在这里需要手动添加</span><br></pre></td></tr></table></figure>
<h2 id="root-null-attachToRoot-true-false"><a href="#root-null-attachToRoot-true-false" class="headerlink" title="root = null,attachToRoot = true | false"></a>root = null,attachToRoot = true | false</h2><p>这个时候由于我们的root为空所以我们的resource布局的根节点的宽高就会失效布局样式就不会是我们编写的效果,无论attachToRoot为true还是false.</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</span><br></pre></td></tr></table></figure>
<p>这个代码最终都会执行到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">        synchronized (mConstructorArgs) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">            final Context inflaterContext &#x3D; mContext;</span><br><span class="line">            final AttributeSet attrs &#x3D; Xml.asAttributeSet(parser);</span><br><span class="line">            Context lastContext &#x3D; (Context) mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] &#x3D; inflaterContext;</span><br><span class="line">            View result &#x3D; root;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Look for the root node.</span><br><span class="line">                int type;</span><br><span class="line">                while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type !&#x3D; XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Empty</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (type !&#x3D; XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                            + &quot;: No start tag found!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final String name &#x3D; parser.getName();</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                    System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                            + name);</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;</span><br><span class="line">                        throw new InflateException(&quot;&lt;merge &#x2F;&gt; can be used only with a valid &quot;</span><br><span class="line">                                + &quot;ViewGroup root and attachToRoot&#x3D;true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;初始化所有的子控件，加载xml内view,并添加到temp中</span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Temp is the root view that was found in the xml</span><br><span class="line">                    final View temp &#x3D; createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    if (root !&#x3D; null) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                    root);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; Create layout params that match root, if supplied</span><br><span class="line">                        params &#x3D; root.generateLayoutParams(attrs);&#x2F;&#x2F;1</span><br><span class="line">                        if (!attachToRoot) &#123;&#x2F;&#x2F;3</span><br><span class="line">                            &#x2F;&#x2F; Set the layout params for temp if we are not</span><br><span class="line">                            &#x2F;&#x2F; attaching. (If we are, we use addView, below)</span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Inflate all children under temp against its context.</span><br><span class="line">                    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; We are supposed to attach all the views we found (int temp)</span><br><span class="line">                    &#x2F;&#x2F; to root. Do that now.</span><br><span class="line">                    if (root !&#x3D; null &amp;&amp; attachToRoot) &#123;&#x2F;&#x2F;2</span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Decide whether to return the root that was passed in or the</span><br><span class="line">                    &#x2F;&#x2F; top view found in xml.</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;&#x2F;&#x2F;4</span><br><span class="line">                        result &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">                final InflateException ie &#x3D; new InflateException(e.getMessage(), e);</span><br><span class="line">                ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">                throw ie;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                final InflateException ie &#x3D; new InflateException(parser.getPositionDescription()</span><br><span class="line">                        + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">                ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">                throw ie;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t retain static reference on context.</span><br><span class="line">                mConstructorArgs[0] &#x3D; lastContext;</span><br><span class="line">                mConstructorArgs[1] &#x3D; null;</span><br><span class="line"></span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当root!=null时我们会先找出根节点的布局参数(1):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params &#x3D; root.generateLayoutParams(attrs);</span><br></pre></td></tr></table></figure>
<p>然后判断当root!=null,attachToRoot=true就会执行(2):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (root !&#x3D; null &amp;&amp; attachToRoot) &#123;&#x2F;&#x2F;2</span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<p>所以如果我们在代码中又重复调用addView的话就会报重复添加view的错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!attachToRoot) &#123;&#x2F;&#x2F;3</span><br><span class="line">                            &#x2F;&#x2F; Set the layout params for temp if we are not</span><br><span class="line">                            &#x2F;&#x2F; attaching. (If we are, we use addView, below)</span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>如果root!=null同时attachToRoot为false这时候就会将刚刚生成的params设置到temp中.<br>如果指定root=null(4)，那么无论attachToRoot为true或者false都会将temp赋值给result.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/07/17/2019-7-17-%E7%90%86%E8%A7%A3LayoutInflate.inflater%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/" data-id="ck8cxir3h002r7g9k8lua0ap7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-7-10-屏幕适配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/" class="article-date">
  <time datetime="2019-07-09T16:00:00.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/">屏幕适配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="最小宽度适配"><a href="#最小宽度适配" class="headerlink" title="最小宽度适配"></a>最小宽度适配</h1><p>Android中屏幕适配的方式有很多种,其中最小宽度适配是通过获取手机屏幕的最小宽度进行适配。<br>在项目中我们通过获取屏幕的最小宽度dp值给定一个基础数据dp。它的计算是：<br>最小宽度(例如:1080)/(手机的dpi/160) = dp.<br>例如：1080*1920,480dpi.根据上面的公式计算得出的dp=360.所以将屏幕的最小宽度就设置为360dp(一般大部分手机屏幕的最小基本数值为360,这样将宽度就等分成360份).<br>将手机屏幕等分成360份之后,需要在项目中的values文件的dimens.xml文件中设置.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">	&lt;dimen name="dp_1"&gt;1dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_2"&gt;2dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_3"&gt;3dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_4"&gt;4dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_5"&gt;5dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_6"&gt;6dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_7"&gt;7dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_8"&gt;8dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_9"&gt;9dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_10"&gt;10dp&lt;/dimen&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;dimen name="dp_356"&gt;356dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_357"&gt;357dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_358"&gt;358dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_359"&gt;359dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_360"&gt;360dp&lt;/dimen&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>这样其他的dp的值就以360作为基础数值计算出适配的大小.<br>360dp是基础数值时，values-sw400dp的计算出来的数值就是:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">	&lt;dimen name="dp_1"&gt;1.1111dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_2"&gt;2.2222dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_3"&gt;3.3333dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_4"&gt;4.4444dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_5"&gt;5.5556dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_6"&gt;6.6667dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_7"&gt;7.7778dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_8"&gt;8.8889dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_9"&gt;10.0000dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_10"&gt;11.1111dp&lt;/dimen&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;dimen name="dp_355"&gt;394.4444dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_356"&gt;395.5556dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_357"&gt;396.6667dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_358"&gt;397.7778dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_359"&gt;398.8889dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_360"&gt;400.0000dp&lt;/dimen&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以保证不管在任何手机上运行只要找到其对应的values-sw<N>dp就可以适配了。<br>但是如果我们计算每个values中的dp具体数据就太麻烦了,可以<a href="https://www.jianshu.com/p/1302ad5a4b04" target="_blank" rel="noopener">参考</a>插件一键生成.<br>通过按照最小宽度适配方案可以达到在不同手机上一样的显示效果但是有几个缺点:<br>1.我们需要设置不同的values-sw<N>dp,这样values下面的dimens.xml就会增加(相对于屏幕分辨率适配要少很多)。<br>2.我们是引用@dimen/dp_N,如果以后又要更换适配方案的话需要更换布局文件中大量的dimen值。<br>但是它也有几个优点:<br>1.相对于屏幕分辨率适配,最小宽度适配是找到屏幕的最小宽度如果没有找到就会继续在valuse-sw<N>dp文件中找到相近匹配的。<br>2.最小宽度的dimens文件中使用dp作为基本单位更加灵活.</p>
<h1 id="今日头条适配方案"><a href="#今日头条适配方案" class="headerlink" title="今日头条适配方案"></a>今日头条适配方案</h1><p>单位换算的源代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Converts an unpacked complex data value holding a dimension to its final floating </span></span><br><span class="line"><span class="comment">    * point value. The two parameters &lt;var&gt;unit&lt;/var&gt; and &lt;var&gt;value&lt;/var&gt;</span></span><br><span class="line"><span class="comment">    * are as in &#123;<span class="doctag">@link</span> #TYPE_DIMENSION&#125;.</span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit The unit to convert from.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value The value to apply the unit to.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> metrics Current display metrics to use in the conversion -- </span></span><br><span class="line"><span class="comment">    *                supplies display density and scaling information.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The complex floating point value multiplied by the appropriate </span></span><br><span class="line"><span class="comment">    * metrics depending on its unit. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      DisplayMetrics metrics)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过修改系统像素的密度值<strong>density</strong>来达到适配我们设计图的效果。系统中是通过屏幕像素(displayMetrics.widthPixels/displayMetrics.heightPixels)/160=density.这里的160我们完全可以换成设计图的尺寸计算出我们自己的density密度然后将我们自己的密度赋值给displayMetrics.density。<br>如果是字体的适配没有修改的时候密度和density是相同的如果修改了字体的大小那密度就不同了这个时候我们可以监听字体大小是否修改来获取改变后的密度。<br>今日头条代码实例(推荐使用DP作为适配方案):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统的Density</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatDensity;</span><br><span class="line"><span class="comment">// 系统的ScaledDensity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(Activity activity, Application application)</span> </span>&#123;</span><br><span class="line">       DisplayMetrics displayMetrics = application.getResources().getDisplayMetrics();</span><br><span class="line">       <span class="keyword">if</span> (sNoncompatDensity == <span class="number">0</span>) &#123;</span><br><span class="line">           sNoncompatDensity = displayMetrics.density;</span><br><span class="line">           sNoncompatScaledDensity = displayMetrics.scaledDensity;</span><br><span class="line">           <span class="comment">// 监听在系统设置中切换字体</span></span><br><span class="line">           application.registerComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (newConfig != <span class="keyword">null</span> &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       sNoncompatScaledDensity=application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此处以360dp的设计图作为例子</span></span><br><span class="line">       <span class="keyword">float</span> targetDensity=displayMetrics.widthPixels/<span class="number">360</span>;</span><br><span class="line">       <span class="keyword">float</span> targetScaledDensity=targetDensity*(sNoncompatScaledDensity/sNoncompatDensity);</span><br><span class="line">       <span class="keyword">int</span> targetDensityDpi= (<span class="keyword">int</span>) (<span class="number">160</span> * targetDensity);</span><br><span class="line">       displayMetrics.density = targetDensity;</span><br><span class="line">       displayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">       displayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">       DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">       activityDisplayMetrics.density = targetDensity;</span><br><span class="line">       activityDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">       activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/1eeb0d8d1c86" target="_blank" rel="noopener">https://www.jianshu.com/p/1eeb0d8d1c86</a><br><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/" data-id="ck8cxir3g002p7g9k1jio804t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-23-Android多线程编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-05-22T16:00:00.000Z" itemprop="datePublished">2019-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">Android多线程编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.学什么：学习Android中的多线程编程。<br>2.怎么学：《Android进阶之光》，博客。<br>3.学到什么为止:掌握多线程的处理方式和原理(synchronized,volatile,阻塞队列，线程池)能够熟练应对Android多线程业务功能的需求，最终能够写一个简易的多线程下载功能。</p>
<h2 id="线程的多种状态"><a href="#线程的多种状态" class="headerlink" title="线程的多种状态"></a>线程的多种状态</h2><p>1.new:新建状态,该线程处于new thread ~ thread.start()之间.<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           synchronized (o) &#123;</span><br><span class="line">               System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   o.wait();</span><br><span class="line">                   o.notify();</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   CarThread carThread &#x3D; new CarThread();</span><br><span class="line">   new Thread(carThread).start();</span><br></pre></td></tr></table></figure>
<p>2.runnable:可执行状态,可以让cpu调度执行.<br>3.running:可运行状态,线程获得cpu的使用权<br>4.blocking:阻塞状态,线程由于某种原因放弃了cpu的使用权，处于暂停（sleep,wait,join,yield,同步锁）.</p>
<ul>
<li>sleep：让当前线程休眠一段时间让出cpu的使用权(但并不会释放锁).<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">         try &#123;</span><br><span class="line">             Thread.sleep(1000);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         System.out.println(&quot;amls running&quot;);</span><br><span class="line">         System.out.println(&quot;amls running end&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 执行结果：</span><br><span class="line"> 汽车 running</span><br><span class="line"> amls running</span><br><span class="line"> amls running end</span><br><span class="line"> 汽车 running end</span><br></pre></td></tr></table></figure></li>
<li>wait:当前线程让出cpu的使用权但是会释放锁(wait的使用必须在同步代码块或者同步方法中)，只有调用notify或者notifyAll,线程的wait状态才会得到解除.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (o) &#123;</span><br><span class="line">                System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    o.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (o) &#123;</span><br><span class="line">                System.out.println(&quot;amls running&quot;);</span><br><span class="line">                o.notify();</span><br><span class="line">                System.out.println(&quot;amls running end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">汽车 running</span><br><span class="line">amls running</span><br><span class="line">amls running end</span><br><span class="line">汽车 running end</span><br></pre></td></tr></table></figure>
<ul>
<li>join：阻塞当前的线程,直到join的线程超时或者结束.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">            System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;amls running&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;amls running end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">amls running</span><br><span class="line">汽车 running</span><br><span class="line">汽车 running end</span><br><span class="line">amls running end</span><br></pre></td></tr></table></figure>
<ul>
<li>yield：当前线程让出cpu的使用权，之后再一起同等争夺(不能理解成让其他线程执行)<br>示例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String carName;</span><br><span class="line"></span><br><span class="line">        public CarThread(String carName) &#123;</span><br><span class="line">            this.carName &#x3D; carName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(carName+&quot;---------&quot;+i);</span><br><span class="line">                if (i &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>5.dead:死亡状态，线程执行完毕或者某种原因异常.</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>线程中断即是让线程在运行过程中被打断了。线程中断不同于stop，stop是向系统发送中断信号强制执行中断，而interrupt则是发送一个中断信号给目标线程，此线程会不时的检查有没有中断信号，如果在线程中不处理这个中断信号那么线程将不会响应中断(注:不是发送一个中断信号当前线程就会终止,还需要目标线程在程序中通过isInterrupt来获取中断信息以此判断是否需要中断.)<br>interrupt可以用来中断一个线程,当一个线程执行了thread.interrupt时当前线程的中断状态就从false转变为true状态。如果一个线程处于阻塞状态，线程在检查中断标记位时发现中断标记为true,就会在阻塞的地方抛出一个异常并且将中断标记位致位false复位。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 响应中断</span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(&quot;Java技术栈线程被中断，程序退出。&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(&quot;sleep执行了&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;Java技术栈线程休眠被中断，程序退出。&quot;);</span><br><span class="line">                    &#x2F;&#x2F;在线程阻塞状态下重新阻塞该线程</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        thread.interrupt();</span><br></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>synchronized关键字:synchronized主要用于多线程中线程同步,解决当有多个线程调用同一个逻辑时数据不同步问题,synchronized关键字可以同步方法也可以同步代码块。当同步方法只有当前就只有一个线程执行其他线程需要等待当前线程执行完<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public static class test7 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String threadName;</span><br><span class="line"></span><br><span class="line">        public test7(String threadName) &#123;</span><br><span class="line">            this.threadName &#x3D; threadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (test7.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(threadName + &quot;正在执行......&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果:</span><br><span class="line">0正在执行......</span><br><span class="line">9正在执行......</span><br><span class="line">8正在执行......</span><br><span class="line">7正在执行......</span><br><span class="line">6正在执行......</span><br><span class="line">5正在执行......</span><br><span class="line">4正在执行......</span><br><span class="line">3正在执行......</span><br><span class="line">2正在执行......</span><br><span class="line">1正在执行......</span><br></pre></td></tr></table></figure>

<ul>
<li>volatile关键字:在开发过程中如果我们为了同步几个实体域就使用synchronized关键字的话，那就开销太大了而volatile关键字为实体域提供了免锁机制。当一个实体域更新了数据之后其他的线程都会看到这个更新(可见性),同时被volatile修饰的实体不能被重排序(保证有序性).<br>volatile在多线程开发中能够保证程序的可见性，有序性但是不保证原子性,因此使用 volatile修饰的实体域不能做自增，自减操作只能做赋值操作.因为原子性的操作在cpu中会被分为好几个步骤执行因此在多线程中有可能当前的线程失去了cpu的控制权导致数据只执行了一半.</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列是支持两个附加操作的队列,当队列为空时，获取元素的线程就会阻塞，直到队列中有数据被添加进来，当队列数据满了时，插入元素的线程就会阻塞，直到队列中有空位置可以使用。<br>Java中的阻塞队列有7种:</p>
<ul>
<li>ArrayBlockingQueue:由数组结构组成的有界阻塞队列.</li>
<li>LinkedBlockingQueue:由链表组成的有界阻塞队列.(当不指定队列大小时，默认为MAX_VALUE)</li>
<li>PriorityBlockingQueue:支持优先级排序的无解阻塞队列。</li>
<li>DelayQueue:使用优先级实现的无界阻塞队列.</li>
<li>SynchronousQueue:不存储元素的阻塞队列.</li>
<li>LinkedTransferQueue:由链表结构组成的无界阻塞队列.</li>
<li>LinkedBlockingDeque:由链表结构组成的双向阻塞队列.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class BlockQueueThread &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(10);</span><br><span class="line"></span><br><span class="line">        ProductThread productThread &#x3D; new ProductThread(linkedBlockingQueue);</span><br><span class="line">        CustomThread customThread &#x3D; new CustomThread(linkedBlockingQueue);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (i &lt; 5) &#123;</span><br><span class="line">                new Thread(productThread).start();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                new Thread(customThread).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建生产者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class ProductThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue;</span><br><span class="line">        private final Random random;</span><br><span class="line"></span><br><span class="line">        ProductThread(LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue) &#123;</span><br><span class="line">            this.linkedBlockingQueue &#x3D; linkedBlockingQueue;</span><br><span class="line">            random &#x3D; new Random();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; random.nextInt(100);</span><br><span class="line">                linkedBlockingQueue.put(i);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;向队列插入数据------&quot; + i);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建消费者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class CustomThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">        CustomThread(LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue) &#123;</span><br><span class="line">            this.linkedBlockingQueue &#x3D; linkedBlockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Integer take &#x3D; linkedBlockingQueue.take();</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;向队列取出数据------&quot; + take);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在编程过程中如果我们在程序中每次都需要开启一个线程执行任务，那么势必会造成系统资源的消耗浪费，所以就有了线程池。线程池的作用就是当我们开启了一个线程任务后将这个线程放入线程池中统一管理，当当前线程处理完任务后不会被销毁而是重用当前线程.<br>创建线程池最好是使用ThreadPoolExecutor这个方法.FixedThreadPool和SingleThreadPool:允许请求的队列长度为interger.MAX_VALUE，可能会堆积大量的请求，导致OOM<br>CacheThreadPool和ScheduledThreadPool:允许创建的线程数量为MAX_VALUE,可能会创建大量的线程,从而导致OOM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看上面代码ThreadPoolExecutor的几个构造方法其中做多的一共需要传入6个参数。这些参数分别为：</p>
<ul>
<li>corePoolSize:核心线程数。默认情况下线程池是空的，只有提交任务时才会创建线程，如果当前运行的线程数少于或等于corePoolSize就不会在创建核心线程。</li>
<li>maximumPoolSize:线程池允许创建的最大线程数。如果任务队列已经满了，并且当前线程数也大于corePoolSize小于maximumPoolSize，则线程会创建新的线程执行任务。</li>
<li>keepAliveTime:非核心线程闲置的时间，当超过这个时候就会回收。</li>
<li>unit:keepAliveTime的时间单位。</li>
<li>BlockingQueue<Runnable>:阻塞队列。如果当前线程数大于corePoolSize就将任务添加到此队列中。</li>
<li>ThreadFactory:线程工厂</li>
<li>RejectedExecutionHandler:饱和策略。当线程池和任务队列都满了时表示无法处理新任务抛出异常。</li>
</ul>
<h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><ul>
<li>Thread是一个类，Runnable是一个接口。</li>
<li>Thread类相对独立不适合多线程资源共享.而Runnable的代码可以被多个线程共享适用于多个线程处理同一资源的情况。</li>
<li>在Runable中虽然可以多个线程进行资源共享但是会存在线程安全问题，所以我们需要在代码中加入锁机制(互斥锁)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ticket implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int ticket &#x3D; 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (ticket.class) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                if (ticket &gt; 0) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;ticket &#x3D; &quot; + ticket--);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ticket ticket &#x3D; new ticket();</span><br><span class="line">new Thread(ticket).start();</span><br><span class="line">new Thread(ticket).start();</span><br><span class="line">new Thread(ticket).start();</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" data-id="ck8cxir3f002n7g9k76q1g9rt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-20-多线程中Future和FutureTask的区别和联系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/" class="article-date">
  <time datetime="2019-05-19T16:00:00.000Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/">多线程中Future和FutureTask的区别和联系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java多线程中我们开启一个线程主要是通过继承Thread类或者实现Runnable接口的方式,但是这两种方式都无法返回线程的执行结果。于是就设计了Future和FutureTask<br>使用Future和FutureTask开启线程需要用到Callable这个接口。<br>Callable的接口定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throw Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出Callable可以返回一个V。</p>
<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future<V>接口</h2><p>Futuer接口是用于获取一个线程执行的结果，对执行的结果进行获取(get)，取消(cancle),判断是否完成等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancle(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get();</span><br><span class="line">    V get(long timeout,TimeUnit unit);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">* V get():获取异步执行的结果，如果没有执行的结果，此方法会阻塞知道异步计算完成。</span><br><span class="line">* V get(long timeout,TimeUnit unit):此方法也是获取异步的执行结果，只不过会有时间限制当超过时间限制时就会抛出异常。</span><br><span class="line">* isDone():任务执行结束,无论是正常结束还是异常取消或者发生异常,都会返回true。</span><br><span class="line">* isCnacelled():任务是否被取消，如果任务在完成前取消则返回true。</span><br><span class="line">* cancle():如果任务还没开始执行取消则返回false，如果任务已经启动执行cancle（true）则任务会以中断的方式试图停止任务，如果停止成功则返回true；当任务已经启动，执行cancle（false）方法将不会对正在执行的任务产生影响，此时返回false；当任务已经完成执行cancle方法将返回false。</span><br><span class="line"></span><br><span class="line">## FutureTask类</span><br><span class="line">FutureTask实现了Future&lt;V&gt;:</span><br></pre></td></tr></table></figure>
<p>public class FutureTask<V> implements RunnableFuture<V> {}</p>
<p>public interface RunnableFuture<V> extends Runnable,Future<V> {}</p>
<pre><code></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/" data-id="ck8cxir3f002k7g9k9eod4yd3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-13-CountDownLatch的使用场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="article-date">
  <time datetime="2019-05-12T16:00:00.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">CountDownLatch的使用场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>countdownlatch能够使一个和多个线程处于等待状态直到其他线程执行完再执行。countdownlatch是通过一个计数器来实现的当一个线程完成后count就会减1,直到计数器为0所有的线程都完成了任务，它的闭锁线程才恢复执行。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class CountDoneLatch &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;1&quot;)).start();</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;2&quot;)).start();</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;3&quot;)).start();</span><br><span class="line">        new Thread(new Boss(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Boss implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private CountDownLatch countDoneLatch;</span><br><span class="line"></span><br><span class="line">        Boss(CountDownLatch countDoneLatch) &#123;</span><br><span class="line">            this.countDoneLatch &#x3D; countDoneLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;boss is check work down...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                countDoneLatch.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;boss is checked ok&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Worker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private final CountDownLatch countDownLatch;</span><br><span class="line">        private final String name;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch countDownLatch, String name) &#123;</span><br><span class="line"></span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;worker&quot; + name + &quot;  work down!&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" data-id="ck8cxir3e002i7g9k9peuaaah" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-4-27-Bitmap位图优化处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2019-04-26T16:00:00.000Z" itemprop="datePublished">2019-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/">Bitmap位图优化处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android中由于Bitmap位图在加载的时候需要很大的内存开销，容易造成程序OOM。因此系统提供了不同的方式解决Bitmap加载问题.</p>
<h2 id="计算Bitmap的尺寸"><a href="#计算Bitmap的尺寸" class="headerlink" title="计算Bitmap的尺寸"></a>计算Bitmap的尺寸</h2><p>加载位图的方式可以通过decodeByteArray(),decodeFile(),decodeResource()等等。这样的加载方式很容易导致OOM异常。每种类型的加载可以通过BitmapFactory.Options类配置解码选项。在解码的过程中可以通过inJustDecodeBounds属性设置true这样在图片只有宽高资源不会加载到内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line">int imageHeight &#x3D; options.outHeight;</span><br><span class="line">int imageWidth &#x3D; options.outWidth;</span><br><span class="line">String imageType &#x3D; options.outMimeType;</span><br></pre></td></tr></table></figure>
<p>这样就已经获取到了图片的尺寸而且资源没有加载到内存，我们就可以操作图片的宽高达到我们规定的大小。我们可以设置自己的采样率大小，将最终计算的值设置给inSimapleSize.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateInSampleSize(</span><br><span class="line">            BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">    &#x2F;&#x2F; Raw height and width of image</span><br><span class="line">    final int height &#x3D; options.outHeight;</span><br><span class="line">    final int width &#x3D; options.outWidth;</span><br><span class="line">    int inSampleSize &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line"></span><br><span class="line">        final int halfHeight &#x3D; height &#x2F; 2;</span><br><span class="line">        final int halfWidth &#x3D; width &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Calculate the largest inSampleSize value that is a power of 2 and keeps both</span><br><span class="line">        &#x2F;&#x2F; height and width larger than the requested height and width.</span><br><span class="line">        while ((halfHeight &#x2F; inSampleSize) &gt;&#x3D; reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth &#x2F; inSampleSize) &gt;&#x3D; reqWidth) &#123;</span><br><span class="line">            inSampleSize *&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置完inSimpleSize之后还需要将inJustDecodeBounds设置为false，因为在这之前图片的资源还没有在内存中，因此现在将图片加载到内存(我们计算后的大小)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,</span><br><span class="line">        int reqWidth, int reqHeight) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First decode with inJustDecodeBounds&#x3D;true to check dimensions</span><br><span class="line">    final BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate inSampleSize</span><br><span class="line">    options.inSampleSize &#x3D; calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decode bitmap with inSampleSize set</span><br><span class="line">    options.inJustDecodeBounds &#x3D; false;</span><br><span class="line">    return BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));</span><br></pre></td></tr></table></figure>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>当我们在无网络环境或者需要频繁访问一个资源图片的时候就可以将我们的数据先加载进内存缓存中然后等需要的时候在取出来这样可以提高一个图片的访问速度.<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取系统运行内存</span><br><span class="line">    final int maxMemory &#x3D; (int) (Runtime.getRuntime().maxMemory() &#x2F; 1024);</span><br><span class="line">    &#x2F;&#x2F;设置缓存大小</span><br><span class="line">    final int cacheSize &#x3D; maxMemory &#x2F; 8;</span><br><span class="line">    lruCache &#x3D; new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected int sizeOf(@NonNull String key, @NonNull Bitmap bitmap) &#123;</span><br><span class="line">            return bitmap.getByteCount() &#x2F; 1024;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">       </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将bitmap设置到缓存中</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">    if (lruCache !&#x3D; null) &#123;</span><br><span class="line">        if (getBitmapFormCache(key) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lruCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;tag&quot;, &quot;图片已经加入缓存了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 从缓存中取出bitmap</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Bitmap getBitmapFormCache(String key) &#123;</span><br><span class="line">    return lruCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>有些时候我们无法保证缓存的数据一直在内存中，例如：当前缓存的应用退到后台被销毁。<br>这个时候就需要磁盘缓存数据,以保证我们的数据减少Bitmap加载次数.磁盘缓存读取数据依然需要在非UI线程中执行，因为我们无法知道当前读取的时长。<br>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">File diskLruCacheDir &#x3D; getDiskLruCacheDir(this);</span><br><span class="line">        try &#123;</span><br><span class="line">            mDiskLruCache &#x3D; DiskLruCache.open(diskLruCacheDir, 1, 1, DISK_CACHE_SIZE);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">private File getDiskLruCacheDir(Context context) &#123;</span><br><span class="line">        final String cachePath &#x3D; Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !isExternalStorageRemovable() ? Objects.requireNonNull(getExternalCacheDir()).getPath() : context.getCacheDir().getPath();</span><br><span class="line">        return new File(cachePath + File.separator + DiskLruCacheActivity.DISK_CACHE_SUBDIR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> try &#123;</span><br><span class="line">                    &#x2F;&#x2F;将bitmap加入硬盘缓存</span><br><span class="line">                    DiskLruCache.Editor edit &#x3D; mDiskLruCache.edit(&quot;100&quot;);</span><br><span class="line">                    OutputStream os &#x3D; edit.newOutputStream(0);</span><br><span class="line">                    URL url &#x3D; new URL(urls);</span><br><span class="line">                    HttpURLConnection urlConnection &#x3D; (HttpURLConnection) url.openConnection();</span><br><span class="line">                    urlConnection.connect();</span><br><span class="line">                    int contentLength &#x3D; urlConnection.getContentLength();</span><br><span class="line">                    BufferedInputStream bis &#x3D; new BufferedInputStream(urlConnection.getInputStream(), contentLength);</span><br><span class="line">                    BufferedOutputStream bos &#x3D; new BufferedOutputStream(os, contentLength);</span><br><span class="line">                    int b;</span><br><span class="line">                    while ((b &#x3D; bis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                        bos.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bos.flush();</span><br><span class="line"></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line"></span><br><span class="line">                    edit.commit();</span><br><span class="line">                    mDiskLruCache.flush();</span><br><span class="line">                &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;   </span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;获取磁盘缓存中的图片</span><br><span class="line">        try &#123;</span><br><span class="line">            DiskLruCache.Snapshot snapshot &#x3D; mDiskLruCache.get(&quot;100&quot;);</span><br><span class="line">            InputStream inputStream &#x3D; snapshot.getInputStream(0);</span><br><span class="line">            Bitmap bitmap &#x3D; BitmapFactory.decodeStream(inputStream);</span><br><span class="line">            diskCacheIv.setImageBitmap(bitmap);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择合适的Bitmap解码方式"><a href="#选择合适的Bitmap解码方式" class="headerlink" title="选择合适的Bitmap解码方式"></a>选择合适的Bitmap解码方式</h2><p>Android系统中Bitmap解码默认是ARGB_8888，也就是一个像素占用4个字节.<br>我们可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;系统默认是ARGB_8888每个像素占4个字节</span><br><span class="line">options.inPreferredConfig &#x3D; Bitmap.Config.ARGB_4444;</span><br></pre></td></tr></table></figure>
<p>设置成其他的解码方式.</p>
<h2 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h2><p>当Bitmap的加载是在gridView或者RecyclerView这样的列表视图中时，由于我们的Bitmap加载每次都会开启一个线程这样就会造成多线程并发问题.</p>
<h2 id="及时回收Bitmap内存"><a href="#及时回收Bitmap内存" class="headerlink" title="及时回收Bitmap内存"></a>及时回收Bitmap内存</h2><p>处理完Bitmap图片之后要记得回收掉Bitmap释放资源。在Android 2.3.3及以下需要调用recycle()函数，在2.3.3以上GC会自动管理。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(Build.VERSION.SDK-INT&lt;&#x3D;10) &#123;</span><br><span class="line">        bitmap.recycle();</span><br><span class="line">&#125;</span><br><span class="line">bitmap &#x3D; null;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/" data-id="ck8cxir3d002g7g9k0bdsacc8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-16-不是市场失灵，而是那啥失灵" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/" class="article-date">
  <time datetime="2019-04-15T16:00:00.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/">不是市场失灵，而是那啥失灵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>不是市场失灵，而是那啥失灵</p>
<p>因为奔驰女车主的维权事件，知名记者王志安起底了4S店的金融服务费乱象。</p>
<p>女车主王倩（化名）的购车经历是这样的：她在买车时计划全款，但是，利之星的销售反复劝她分期，在缴纳了20多万首付、办完贷款之后，销售突然通知她要缴纳15000元的金融服务费。</p>
<p>顺着这个事，王志安去了解了4S店的一些潜规则：</p>
<p>汽车销售原本是暴利行业。早些年，投资一家4S店，快的两三年就可以收回本金。</p>
<p>但最近几年，竞争日趋激烈，收益率在持续下降。随着价格战越来越激烈，汽车销售的毛利率越来越低，许多4S店零利润甚至负利润也会销售，这就是业内熟知的价格倒挂现象。</p>
<p>因为厂商会在年终时根据销售业绩给4S店返点，如果销售业绩上去了，虽然单车销售可能是亏损的，但算上返点依然有得赚。</p>
<p>除此之外，4S店还挖空心思开发其他盈利点，金融服务费、保险抵押金、店内强制搭售保险、高价销售配件，有些品牌还有出库费、牌费等收费项目，就在这一背景下粉墨登场了。</p>
<p>渐渐地，中国的汽车销售行业形成了这么一种通用模式：用不真实的低价吸引顾客进店，然后再谈交易，交易达成过程中，通过其他附加交易赚取利润。</p>
<p>最后，王老师对这种乱象开出了“政府管一管”的唯一药方：</p>
<p>有什么办法改变么？</p>
<p>只有一个办法，</p>
<p>政府对这个日渐混乱的市场强监管。取消不合法的金融服务费，废除强制搭售的店内保险，取消4S店的一切强制搭售。</p>
<p>如此，这个市场才会逐渐回归服务和诚信。</p>
<p>微博上有网友，甚至包括来去之间这样的微博CEO也认为，这件事反应了市场没能奖优罚劣，是市场失灵的明证。</p>
<p>王志安是一位比较专业的调查记者，我们假设他对事实的调查都是对的，但给出的结论和对策却是完全错的。</p>
<p>首先，我们看女车主王倩的遭遇，她在被诱导办理分期买车之后，突然被告知需要另交15000元的金融服务费。</p>
<p>王倩对此事提出两点质疑：第一、这属于消费欺诈，因为事先没人告知她有这笔开支；第二，所谓的服务并不存在，贷款手续是她自己办的。</p>
<p>王倩的表达非常清晰，这个案子体现的并不是自愿交易的市场行为，而是欺诈，是生米煮成熟饭之后的敲竹杠。</p>
<p>假如我们处在一个更为理想的市场环境里，这种情况可能会以什么方式解决呢？在这个环境里，我们会有真正站在消费者立场的消费者权益保护机构，他们将高效动用舆论或者司法资源来解决这个冲突。</p>
<p>这些机构存在的根基，来源于真正维护消费者权益的举动，而不是税收的无条件供养。这些机构也是彼此竞争的，为了赢得消费者的信任，它们不得不以越来越高的效率、越来越低的成本来解决此类冲突。</p>
<p>现实中，正是因为权力在很大程度上垄断了处理此类冲突的事权，才会导致相应组织（比如工商局、消协，它们有竞争对手吗？）效率低下，它们的核心诉求不是真正解决消费者的问题，而是多一事不如少一事。</p>
<p>想想吧，如果王倩只要打一个电话给消协投诉，就能解决她和奔驰之间的冲突，一个买得起奔驰车的人，何苦撕破脸大闹4S店呢？</p>
<p>现实中就有典型的案例，前段时间，为了加强竞争力，某电商平台升级退换货服务，甚至不需要填理由，点下手指，就有专人上门取货。这可不是因为他们老板良心好，而是因为要面对激烈的市场竞争。</p>
<p>人们容易对市场有两个误会：</p>
<p>一是认为市场应该杜绝一切恶行，如果出现了不完美的情况，那就是市场失灵。实际上，市场只是一种最高效、最经济的选择。再自由的市场，一样会有恶人存在，但市场可以用更低的成本解决或者改善这些问题。完美的世界，只存在于想象中的天国。</p>
<p>第二个误会是，以王倩的案子为例，很多人认为市场的参与主体就是王倩和利之星4S店。西安利之星把王倩欺负成这样，那就是市场失灵了。实际上，市场主体可以是每一个人和机构，王倩的案子是怎么解决的？是她大闹4S店的视频被传到微博，引发众怒才得到解决的。</p>
<p>在这过程中，每一个关注此事的人，都不同程度地参与其中，包括王志安。王志安做这个调查报告，也许不能从王倩身上获得什么直接收益，但收获了粉丝和关注度吧？再次加强了良心大V的人设吧？</p>
<p>感谢市场带来的媒体大发展吧，如果时间回到十几年前，没有自媒体的时代，这位女士就算哭死了也未必有人能帮她。</p>
<p>西安奔驰这个案子的本质是什么呢？是政府（当地工商局、消协）失灵了，王倩不得不撕破脸皮放手一搏，巧妙地撬动了其他市场主体（看客、媒体、媒体平台）的力量，解决了这个问题。</p>
<p>至于王志安说的，4S店卖车不赚钱，只能掏空心思通过别的服务赚钱，我作为一个消费者，怎么看就怎么觉得这是好事。难道我们还应该期待回到4S店卖车暴利，一辆车赚你十几万的时代吗？</p>
<p>4S店目前的这种商业模式，不就跟微信让你免费使用，然后通过一些增值服务来赚钱是一个道理吗？</p>
<p>只要提前告知购车过程中将发生的各种费用，消费者能够自由选择即可，是不是捆绑销售根本不重要。我们真正应该反对的，是这个过程中发生的欺诈现象，而不是这种商业模式本身。</p>
<p>如果按王志安给出的药方：</p>
<p>政府对这个日渐混乱的市场强监管。取消不合法的金融服务费，废除强制搭售的店内保险，取消4S店的一切强制搭售。</p>
<p>这个市场在恢复服务和诚信之前（能不能恢复还不知道，但监管成本一定会迅速增长），车辆一定会先恢复昂贵。</p>
<p>最后，我们再看一个市场显灵的例子吧，算是送李想一次免费广告：</p>
<p>对于真正有远见的企业家而言，市场上的任何痛点，都可能成为他们的盈利点，这样的人多了，剩下的商家要么跟进，要么被淘汰，这也是我们对市场的信心所在：</p>
<p>只要让人自由逐利，这个世界只能越来越好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/" data-id="ck8cxir2t00117g9k4grh1ve0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/" rel="tag">仓央嘉措菜</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-01-Android属性动画源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Android属性动画源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android属性动画的用法主要是针对某一个属性设置具体的动画效果。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator</span><br><span class="line">.ofInt(target,propName,values[])</span><br><span class="line">.setInterpolator(LinearInterpolator)</span><br><span class="line">.setEvaluator(IntEvaluator)</span><br><span class="line">.setDuration(500)</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure>
<p>设置动画作用于view，设置它变化的数据，以及插值器和估值器等最后调用start方法执行动画。</p>
<h2 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectAnimator ofInt(Object target, String propertyName, int... values) &#123;</span><br><span class="line">ObjectAnimator anim &#x3D; new ObjectAnimator(target, propertyName);</span><br><span class="line">anim.setIntValues(values);</span><br><span class="line">return anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中首先调用了ofInt方法设置要变化的数据。在源代码中首先通过ObjectAnimator属性动画的构造方法，传入作用的属性<br>target和propertyName.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private ObjectAnimator(Object target, String propertyName) &#123;</span><br><span class="line">mTarget &#x3D; target;</span><br><span class="line">setPropertyName(propertyName);</span><br><span class="line">&#125;</span><br><span class="line">public void setPropertyName(String propertyName) &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">mPropertyName &#x3D; propertyName;</span><br><span class="line">mInitialized &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法里面主要是讲target和propertyName记录下来赋值给mTarget和mPropertyName。<br>记录完成后调用setIntValues(values);从调用的名称可以看出这个主要是设置我们传入的具体数值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setIntValues(int... values)</span><br><span class="line">setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setIntValues中调用了setValues将上面的propertyName和valuse传入到PropertyValuesHolder的ofInt中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123;</span><br><span class="line">return new IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line">public IntPropertyValuesHolder(String propertyName, int... values) &#123;</span><br><span class="line">mPropertyName &#x3D; propertyName;</span><br><span class="line">setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void setIntValues(int... values) &#123;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">mKeyframeSet &#x3D; KeyframeSet.ofInt(values);</span><br><span class="line">mIntKeyframeSet &#x3D; (IntKeyframeSet) mKeyframeSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从PropertyValuesHolder中可以看到将propertyName赋值给了mPropertyName，传出了mValuesType<br>然后还存储了mIntKeyframeSet，从字面意思看是关键帧。这里的mKeyframeSet是由KeyframeSet.ofInt方法获取到的是keyframe的集合，而keyframe叫做关键帧为动画保存time/value对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static KeyframeSet ofInt(int... values) &#123;</span><br><span class="line">int numKeyframes &#x3D; values.length;</span><br><span class="line">IntKeyframe keyframes[] &#x3D; new IntKeyframe[Math.max(numKeyframes,2)];</span><br><span class="line">if (numKeyframes &#x3D;&#x3D; 1) &#123;</span><br><span class="line">keyframes[0] &#x3D; (IntKeyframe) Keyframe.ofInt(0f);</span><br><span class="line">keyframes[1] &#x3D; (IntKeyframe) Keyframe.ofInt(1f, values[0]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">return new IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br><span class="line">public IntKeyframeSet(IntKeyframe... keyframes) &#123;</span><br><span class="line">mNumKeyframes &#x3D; keyframes.length;</span><br><span class="line">mKeyframes &#x3D; new ArrayList&lt;Keyframe&gt;();</span><br><span class="line">mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">mFirstKeyframe &#x3D; mKeyframes.get(0);</span><br><span class="line">mLastKeyframe &#x3D; mKeyframes.get(mNumKeyframes - 1);</span><br><span class="line">mInterpolator &#x3D; mLastKeyframe.getInterpolator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先根据values的长度设置一个keyframes数组，由于我们这里之传入了一个values，所以这个keyframes的长度就是2.然后通过keyframe的ofInt方法去构造keyframe对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IntKeyframe(float fraction, int value) &#123;</span><br><span class="line">mFraction &#x3D; fraction;</span><br><span class="line">mValue &#x3D; value;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">mHasValue &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">IntKeyframe(float fraction) &#123;</span><br><span class="line">mFraction &#x3D; fraction;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只是对fraction和value进行了赋值操作。然后拿到keyframes数组后调用了IntKeyframeSet方法。<br>初始化IntKeyframeSet内的一些成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public IntKeyframeSet(IntKeyframe... keyframes) &#123;</span><br><span class="line">mNumKeyframes &#x3D; keyframes.length;</span><br><span class="line">mKeyframes &#x3D; new ArrayList&lt;Keyframe&gt;();</span><br><span class="line">mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">mFirstKeyframe &#x3D; mKeyframes.get(0);</span><br><span class="line">mLastKeyframe &#x3D; mKeyframes.get(mNumKeyframes - 1);</span><br><span class="line">mInterpolator &#x3D; mLastKeyframe.getInterpolator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后最终返回了PropertyValuesHolder.ofInt，最终将target，keyframe，valueType交给了setValues中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void setValues(PropertyValuesHolder... values) &#123;</span><br><span class="line">int numValues &#x3D; values.length;</span><br><span class="line">mValues &#x3D; values;</span><br><span class="line">mValuesMap &#x3D; new HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">PropertyValuesHolder valuesHolder &#x3D; values[i];</span><br><span class="line">mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终将PropertyValuesHolder的values，然后通过一个mValuesMap记录以key为属性名称，值为PropertyValuesHolder。</p>
<h2 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setInterpolator(TimeInterpolator value) &#123;</span><br><span class="line">if (value !&#x3D; null) &#123;</span><br><span class="line">mInterpolator &#x3D; value;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mInterpolator &#x3D; new LinearInterpolator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这主要就是记录一下插值器，从源码可以看出<strong>默认是线性的插值器</strong>。</p>
<h2 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setEvaluator(TypeEval    uator value) &#123;</span><br><span class="line">if (value !&#x3D; null &amp;&amp; mValues !&#x3D; null &amp;&amp; mValues.length &gt; 0) &#123;</span><br><span class="line">mValues[0].setEvaluator(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其中有个mValues就是在ofInt中初始化的PropertyValuesHolder。然后调用PropertyValuesHolder.setEvalutor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setEvaluator(TypeEvaluator evaluator) &#123;</span><br><span class="line">mEvaluator &#x3D; evaluator;</span><br><span class="line">mKeyframeSet.setEvaluator(evaluator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是记录一下设置的估值器然后将估值器传入mKeyframeSet中。</p>
<h2 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private long mDuration &#x3D; (long)(300 * sDurationScale);</span><br><span class="line">private long mUnscaledDuration &#x3D; 300;</span><br><span class="line">private static float sDurationScale &#x3D; 1.0f;</span><br><span class="line">public ObjectAnimator setDuration(long duration) &#123;</span><br><span class="line">if (duration &lt; 0) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Animators cannot have negative duration: &quot; +</span><br><span class="line">duration);</span><br><span class="line">&#125;</span><br><span class="line">mUnscaledDuration &#x3D; duration;</span><br><span class="line">mDuration &#x3D; (long)(duration * sDurationScale);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置动画的执行时间。<br>keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value(这个是我们要传入的真正的数值) , hasValue）。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>设置完动画的所有参数后,接下来就到了最关键的start方法了，在这里执行动画的操作 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">super.start();</span><br><span class="line">&#125;</span><br><span class="line">ValueAnimator</span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">start(false);</span><br><span class="line">&#125;</span><br><span class="line">ValueAnimator</span><br><span class="line">private void start(boolean playBackwards) &#123;</span><br><span class="line">if (Looper.myLooper() &#x3D;&#x3D; null) &#123;</span><br><span class="line">throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mPlayingBackwards &#x3D; playBackwards;</span><br><span class="line">mCurrentIteration &#x3D; 0;</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mStarted &#x3D; true;</span><br><span class="line">mStartedDelay &#x3D; false;</span><br><span class="line">mPaused &#x3D; false;</span><br><span class="line">AnimationHandler animationHandler &#x3D; getOrCreateAnimationHandler();</span><br><span class="line">animationHandler.mPendingAnimations.add(this);</span><br><span class="line">if (mStartDelay &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; This sets the initial value of the animation, prior to actually starting it running</span><br><span class="line">setCurrentPlayTime(0);</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mRunning &#x3D; true;</span><br><span class="line">notifyStartListeners();</span><br><span class="line">&#125;</span><br><span class="line">animationHandler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终从ObjectAnimator的start执行到了ValueAnimator的 start方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mPlayingBackwards &#x3D; playBackwards;</span><br><span class="line">mCurrentIteration &#x3D; 0;</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mStarted &#x3D; true;</span><br><span class="line">mStartedDelay &#x3D; false;</span><br><span class="line">mPaused &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>这里主要是设置动画的一些标记位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimationHandler animationHandler &#x3D; getOrCreateAnimationHandler();</span><br><span class="line">animationHandler.mPendingAnimations.add(this);</span><br></pre></td></tr></table></figure>
<p>这里主要是生成一个AnimationHandler对象这里主要是存储各种状态的valueAnimator。</p>
<h2 id="setCurrentPlayTime"><a href="#setCurrentPlayTime" class="headerlink" title="setCurrentPlayTime"></a>setCurrentPlayTime</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void setCurrentPlayTime(long playTime) &#123;</span><br><span class="line">        initAnimation();</span><br><span class="line">        long currentTime &#x3D; AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">        if (mPlayingState !&#x3D; RUNNING) &#123;</span><br><span class="line">            mSeekTime &#x3D; playTime;</span><br><span class="line">            mPlayingState &#x3D; SEEKED;</span><br><span class="line">        &#125;</span><br><span class="line">        mStartTime &#x3D; currentTime - playTime;</span><br><span class="line">        doAnimationFrame(currentTime);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>首先调用initAnimation初始化动画，然后调用 系统的现在时间currentTime，然后把mPlayingState设置为SEEKED状态，最后调用doAnimationFrame方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void initAnimation() &#123;</span><br><span class="line">        if (!mInitialized) &#123;</span><br><span class="line">            int numValues &#x3D; mValues.length;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">                mValues[i].init();</span><br><span class="line">            &#125;</span><br><span class="line">            mInitialized &#x3D; true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是设置我们 IntPropertyValueHolder的mEvaluator。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PropertyValueHolder的init方法</span><br><span class="line">void init() &#123;</span><br><span class="line">        if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We already handle int and float automatically, but not their Object</span><br><span class="line">            &#x2F;&#x2F; equivalents</span><br><span class="line">            mEvaluator &#x3D; (mValueType &#x3D;&#x3D; Integer.class) ? sIntEvaluator :</span><br><span class="line">                    (mValueType &#x3D;&#x3D; Float.class) ? sFloatEvaluator :</span><br><span class="line">                    null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mEvaluator !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; KeyframeSet knows how to evaluate the common types - only give it a custom</span><br><span class="line">            &#x2F;&#x2F; evaluator if one has been set on this class</span><br><span class="line">            mKeyframeSet.setEvaluator(mEvaluator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置IntPropertyValueHolder的mEvaluator的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final boolean doAnimationFrame(long frameTime) &#123;</span><br><span class="line">        </span><br><span class="line">        final long currentTime &#x3D; Math.max(frameTime, mStartTime);</span><br><span class="line">        return animationFrame(currentTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了animationFrame</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean animationFrame(long currentTime) &#123;</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        switch (mPlayingState) &#123;</span><br><span class="line">        case RUNNING:</span><br><span class="line">        case SEEKED:</span><br><span class="line">            float fraction &#x3D; mDuration &gt; 0 ? (float)(currentTime - mStartTime) &#x2F; mDuration : 1f;</span><br><span class="line">            if (fraction &gt;&#x3D; 1f) &#123;</span><br><span class="line">               &#x2F;&#x2F;...</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPlayingBackwards) &#123;</span><br><span class="line">                fraction &#x3D; 1f - fraction;</span><br><span class="line">            &#125;</span><br><span class="line">            animateValue(fraction);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return done;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据上面 代码中设置的动画执行 状态判断 执行到SEEKED。设置动画执行的fraction<br>然后执行了animaeValue方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void animateValue(float fraction) &#123;</span><br><span class="line">        fraction &#x3D; mInterpolator.getInterpolation(fraction);</span><br><span class="line">        mCurrentFraction &#x3D; fraction;</span><br><span class="line">        int numValues &#x3D; mValues.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].calculateValue(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mUpdateListeners !&#x3D; null) &#123;</span><br><span class="line">            int numListeners &#x3D; mUpdateListeners.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                mUpdateListeners.get(i).onAnimationUpdate(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       int numValues &#x3D; mValues.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].setAnimatedValue(mTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里传入我们计算的fraction获取插值器处理后的fraction。<br>接下来执行 mValues[i].calculateValue(fraction)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void calculateValue(float fraction) &#123;</span><br><span class="line">mAnimatedValue &#x3D; mKeyframeSet.getValue(fraction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部又调用了getValue方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Object getValue(float fraction) &#123;</span><br><span class="line">        return getIntValue(fraction);</span><br><span class="line">    &#125;</span><br><span class="line">public int getIntValue(float fraction) &#123;</span><br><span class="line">        if (mNumKeyframes &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (firstTime) &#123;</span><br><span class="line">                firstTime &#x3D; false;</span><br><span class="line">                firstValue &#x3D; ((IntKeyframe) mKeyframes.get(0)).getIntValue();</span><br><span class="line">                lastValue &#x3D; ((IntKeyframe) mKeyframes.get(1)).getIntValue();</span><br><span class="line">                deltaValue &#x3D; lastValue - firstValue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mInterpolator !&#x3D; null) &#123;</span><br><span class="line">                fraction &#x3D; mInterpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return firstValue + (int)(fraction * deltaValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;...省略了很多代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个里面就是调用估值算法通过fraction的值设置动画每一帧执行多少，然后for循环拿到所有的动画执行的百分比计算的数值后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">               return firstValue + (int)(fraction * deltaValue);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>最终给了 IntPropertyValueHolder的 mIntAnimatedValue属性。<br>接下来调用 mValues[i].setAnimatedValue(mTarget);计算后的值通过反射将其设置到set中。<br>最终调用了animationHandler的start方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">private void scheduleAnimation() &#123;</span><br><span class="line">            if (!mAnimationScheduled) &#123;</span><br><span class="line">                mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);</span><br><span class="line">                mAnimationScheduled &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>根据运行时间继续调用doAnimationFrame方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="ck8cxir2r000x7g9kd5s87cvo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 17.5px;">Java</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" style="font-size: 15px;">个人总结</a> <a href="/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/" style="font-size: 12.5px;">仓央嘉措菜</a> <a href="/tags/%E5%90%B4%E4%B8%BB%E4%BB%BB%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7/" style="font-size: 15px;">吴主任的公众号</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">多线程编程</a> <a href="/tags/%E8%A4%9A%E6%98%8E%E5%AE%87/" style="font-size: 10px;">褚明宇</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 17.5px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/06/2020-1-06-12%E6%9C%88%E4%BB%BD%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">12月份的个人总结</a>
          </li>
        
          <li>
            <a href="/2019/12/31/2019-12-31-%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/">软引用和弱引用</a>
          </li>
        
          <li>
            <a href="/2019/12/06/2019-12-06-Android%20TextView%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">Android TextView源代码分析</a>
          </li>
        
          <li>
            <a href="/2019/12/01/2019-12-01-11%E6%9C%88%E4%BB%BD%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/">11月份的个人总结</a>
          </li>
        
          <li>
            <a href="/2019/11/12/2019-11-12-Http%E8%AF%B7%E6%B1%82%E5%A4%B4Cache-Control%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">Http请求头Cache-Control机制详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 JoshuaYingWhatEgr<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>