<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>page/3/index | JoshuaYingWhatEgr Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JoshuaYingWhatEgr Blogs                                                                                       JoshuaYingWhatEgr Blogs">
<meta property="og:type" content="article">
<meta property="og:title" content="page&#x2F;3&#x2F;index">
<meta property="og:url" content="https://joshuayingwhategr.github.io/2020/10/15/page/3/index/index.html">
<meta property="og:site_name" content="JoshuaYingWhatEgr Blogs">
<meta property="og:description" content="JoshuaYingWhatEgr Blogs                                                                                       JoshuaYingWhatEgr Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-10-15T03:18:44.739Z">
<meta property="article:modified_time" content="2020-10-15T03:18:44.740Z">
<meta property="article:author" content="JoshuaYingWhatEgr">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoshuaYingWhatEgr Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joshuayingwhategr.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-page/3/index" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/15/page/3/index/" class="article-date">
  <time datetime="2020-10-15T03:18:44.739Z" itemprop="datePublished">2020-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      page/3/index
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JoshuaYingWhatEgr Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoshuaYingWhatEgr Blogs">
<meta property="og:url" content="https://joshuayingwhategr.github.io/page/3/index.html">
<meta property="og:site_name" content="JoshuaYingWhatEgr Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JoshuaYingWhatEgr">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoshuaYingWhatEgr Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joshuayingwhategr.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-7-10-屏幕适配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/" class="article-date">
  <time datetime="2019-07-09T16:00:00.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/">屏幕适配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="最小宽度适配"><a href="#最小宽度适配" class="headerlink" title="最小宽度适配"></a>最小宽度适配</h1><p>Android中屏幕适配的方式有很多种,其中最小宽度适配是通过获取手机屏幕的最小宽度进行适配。<br>在项目中我们通过获取屏幕的最小宽度dp值给定一个基础数据dp。它的计算是：<br>最小宽度(例如:1080)/(手机的dpi/160) = dp.<br>例如：1080*1920,480dpi.根据上面的公式计算得出的dp=360.所以将屏幕的最小宽度就设置为360dp(一般大部分手机屏幕的最小基本数值为360,这样将宽度就等分成360份).<br>将手机屏幕等分成360份之后,需要在项目中的values文件的dimens.xml文件中设置.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">	&lt;dimen name="dp_1"&gt;1dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_2"&gt;2dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_3"&gt;3dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_4"&gt;4dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_5"&gt;5dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_6"&gt;6dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_7"&gt;7dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_8"&gt;8dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_9"&gt;9dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_10"&gt;10dp&lt;/dimen&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;dimen name="dp_356"&gt;356dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_357"&gt;357dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_358"&gt;358dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_359"&gt;359dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_360"&gt;360dp&lt;/dimen&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>这样其他的dp的值就以360作为基础数值计算出适配的大小.<br>360dp是基础数值时，values-sw400dp的计算出来的数值就是:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">	&lt;dimen name="dp_1"&gt;1.1111dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_2"&gt;2.2222dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_3"&gt;3.3333dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_4"&gt;4.4444dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_5"&gt;5.5556dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_6"&gt;6.6667dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_7"&gt;7.7778dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_8"&gt;8.8889dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_9"&gt;10.0000dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_10"&gt;11.1111dp&lt;/dimen&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;dimen name="dp_355"&gt;394.4444dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_356"&gt;395.5556dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_357"&gt;396.6667dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_358"&gt;397.7778dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_359"&gt;398.8889dp&lt;/dimen&gt;</span><br><span class="line">	&lt;dimen name="dp_360"&gt;400.0000dp&lt;/dimen&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以保证不管在任何手机上运行只要找到其对应的values-sw<N>dp就可以适配了。<br>但是如果我们计算每个values中的dp具体数据就太麻烦了,可以<a href="https://www.jianshu.com/p/1302ad5a4b04" target="_blank" rel="noopener">参考</a>插件一键生成.<br>通过按照最小宽度适配方案可以达到在不同手机上一样的显示效果但是有几个缺点:<br>1.我们需要设置不同的values-sw<N>dp,这样values下面的dimens.xml就会增加(相对于屏幕分辨率适配要少很多)。<br>2.我们是引用@dimen/dp_N,如果以后又要更换适配方案的话需要更换布局文件中大量的dimen值。<br>但是它也有几个优点:<br>1.相对于屏幕分辨率适配,最小宽度适配是找到屏幕的最小宽度如果没有找到就会继续在valuse-sw<N>dp文件中找到相近匹配的。<br>2.最小宽度的dimens文件中使用dp作为基本单位更加灵活.</p>
<h1 id="今日头条适配方案"><a href="#今日头条适配方案" class="headerlink" title="今日头条适配方案"></a>今日头条适配方案</h1><p>单位换算的源代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Converts an unpacked complex data value holding a dimension to its final floating </span></span><br><span class="line"><span class="comment">    * point value. The two parameters &lt;var&gt;unit&lt;/var&gt; and &lt;var&gt;value&lt;/var&gt;</span></span><br><span class="line"><span class="comment">    * are as in &#123;<span class="doctag">@link</span> #TYPE_DIMENSION&#125;.</span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit The unit to convert from.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value The value to apply the unit to.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> metrics Current display metrics to use in the conversion -- </span></span><br><span class="line"><span class="comment">    *                supplies display density and scaling information.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The complex floating point value multiplied by the appropriate </span></span><br><span class="line"><span class="comment">    * metrics depending on its unit. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      DisplayMetrics metrics)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">       <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">           <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过修改系统像素的密度值<strong>density</strong>来达到适配我们设计图的效果。系统中是通过屏幕像素(displayMetrics.widthPixels/displayMetrics.heightPixels)/160=density.这里的160我们完全可以换成设计图的尺寸计算出我们自己的density密度然后将我们自己的密度赋值给displayMetrics.density。<br>如果是字体的适配没有修改的时候密度和density是相同的如果修改了字体的大小那密度就不同了这个时候我们可以监听字体大小是否修改来获取改变后的密度。<br>今日头条代码实例(推荐使用DP作为适配方案):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统的Density</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatDensity;</span><br><span class="line"><span class="comment">// 系统的ScaledDensity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(Activity activity, Application application)</span> </span>&#123;</span><br><span class="line">       DisplayMetrics displayMetrics = application.getResources().getDisplayMetrics();</span><br><span class="line">       <span class="keyword">if</span> (sNoncompatDensity == <span class="number">0</span>) &#123;</span><br><span class="line">           sNoncompatDensity = displayMetrics.density;</span><br><span class="line">           sNoncompatScaledDensity = displayMetrics.scaledDensity;</span><br><span class="line">           <span class="comment">// 监听在系统设置中切换字体</span></span><br><span class="line">           application.registerComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (newConfig != <span class="keyword">null</span> &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       sNoncompatScaledDensity=application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此处以360dp的设计图作为例子</span></span><br><span class="line">       <span class="keyword">float</span> targetDensity=displayMetrics.widthPixels/<span class="number">360</span>;</span><br><span class="line">       <span class="keyword">float</span> targetScaledDensity=targetDensity*(sNoncompatScaledDensity/sNoncompatDensity);</span><br><span class="line">       <span class="keyword">int</span> targetDensityDpi= (<span class="keyword">int</span>) (<span class="number">160</span> * targetDensity);</span><br><span class="line">       displayMetrics.density = targetDensity;</span><br><span class="line">       displayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">       displayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">       DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">       activityDisplayMetrics.density = targetDensity;</span><br><span class="line">       activityDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">       activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.jianshu.com/p/1eeb0d8d1c86" target="_blank" rel="noopener">https://www.jianshu.com/p/1eeb0d8d1c86</a><br><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/07/10/2019-7-10-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/" data-id="ck8tr9s7n002ln29kg8cq0pyc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-23-Android多线程编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-05-22T16:00:00.000Z" itemprop="datePublished">2019-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">Android多线程编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.学什么：学习Android中的多线程编程。<br>2.怎么学：《Android进阶之光》，博客。<br>3.学到什么为止:掌握多线程的处理方式和原理(synchronized,volatile,阻塞队列，线程池)能够熟练应对Android多线程业务功能的需求，最终能够写一个简易的多线程下载功能。</p>
<h2 id="线程的多种状态"><a href="#线程的多种状态" class="headerlink" title="线程的多种状态"></a>线程的多种状态</h2><p>1.new:新建状态,该线程处于new thread ~ thread.start()之间.<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           synchronized (o) &#123;</span><br><span class="line">               System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">               try &#123;</span><br><span class="line">                   o.wait();</span><br><span class="line">                   o.notify();</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   CarThread carThread &#x3D; new CarThread();</span><br><span class="line">   new Thread(carThread).start();</span><br></pre></td></tr></table></figure>
<p>2.runnable:可执行状态,可以让cpu调度执行.<br>3.running:可运行状态,线程获得cpu的使用权<br>4.blocking:阻塞状态,线程由于某种原因放弃了cpu的使用权，处于暂停（sleep,wait,join,yield,同步锁）.</p>
<ul>
<li>sleep：让当前线程休眠一段时间让出cpu的使用权(但并不会释放锁).<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">         try &#123;</span><br><span class="line">             Thread.sleep(1000);</span><br><span class="line">         &#125; catch (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         System.out.println(&quot;amls running&quot;);</span><br><span class="line">         System.out.println(&quot;amls running end&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> 执行结果：</span><br><span class="line"> 汽车 running</span><br><span class="line"> amls running</span><br><span class="line"> amls running end</span><br><span class="line"> 汽车 running end</span><br></pre></td></tr></table></figure></li>
<li>wait:当前线程让出cpu的使用权但是会释放锁(wait的使用必须在同步代码块或者同步方法中)，只有调用notify或者notifyAll,线程的wait状态才会得到解除.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (o) &#123;</span><br><span class="line">                System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    o.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (o) &#123;</span><br><span class="line">                System.out.println(&quot;amls running&quot;);</span><br><span class="line">                o.notify();</span><br><span class="line">                System.out.println(&quot;amls running end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">汽车 running</span><br><span class="line">amls running</span><br><span class="line">amls running end</span><br><span class="line">汽车 running end</span><br></pre></td></tr></table></figure>
<ul>
<li>join：阻塞当前的线程,直到join的线程超时或者结束.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;汽车 running&quot;);</span><br><span class="line">            System.out.println(&quot;汽车 running end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AmlsThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;amls running&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;amls running end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">amls running</span><br><span class="line">汽车 running</span><br><span class="line">汽车 running end</span><br><span class="line">amls running end</span><br></pre></td></tr></table></figure>
<ul>
<li>yield：当前线程让出cpu的使用权，之后再一起同等争夺(不能理解成让其他线程执行)<br>示例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class CarThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String carName;</span><br><span class="line"></span><br><span class="line">        public CarThread(String carName) &#123;</span><br><span class="line">            this.carName &#x3D; carName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(carName+&quot;---------&quot;+i);</span><br><span class="line">                if (i &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>5.dead:死亡状态，线程执行完毕或者某种原因异常.</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>线程中断即是让线程在运行过程中被打断了。线程中断不同于stop，stop是向系统发送中断信号强制执行中断，而interrupt则是发送一个中断信号给目标线程，此线程会不时的检查有没有中断信号，如果在线程中不处理这个中断信号那么线程将不会响应中断(注:不是发送一个中断信号当前线程就会终止,还需要目标线程在程序中通过isInterrupt来获取中断信息以此判断是否需要中断.)<br>interrupt可以用来中断一个线程,当一个线程执行了thread.interrupt时当前线程的中断状态就从false转变为true状态。如果一个线程处于阻塞状态，线程在检查中断标记位时发现中断标记为true,就会在阻塞的地方抛出一个异常并且将中断标记位致位false复位。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F; 响应中断</span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(&quot;Java技术栈线程被中断，程序退出。&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(&quot;sleep执行了&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;Java技术栈线程休眠被中断，程序退出。&quot;);</span><br><span class="line">                    &#x2F;&#x2F;在线程阻塞状态下重新阻塞该线程</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        thread.interrupt();</span><br></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>synchronized关键字:synchronized主要用于多线程中线程同步,解决当有多个线程调用同一个逻辑时数据不同步问题,synchronized关键字可以同步方法也可以同步代码块。当同步方法只有当前就只有一个线程执行其他线程需要等待当前线程执行完<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public static class test7 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String threadName;</span><br><span class="line"></span><br><span class="line">        public test7(String threadName) &#123;</span><br><span class="line">            this.threadName &#x3D; threadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (test7.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(threadName + &quot;正在执行......&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">执行结果:</span><br><span class="line">0正在执行......</span><br><span class="line">9正在执行......</span><br><span class="line">8正在执行......</span><br><span class="line">7正在执行......</span><br><span class="line">6正在执行......</span><br><span class="line">5正在执行......</span><br><span class="line">4正在执行......</span><br><span class="line">3正在执行......</span><br><span class="line">2正在执行......</span><br><span class="line">1正在执行......</span><br></pre></td></tr></table></figure>

<ul>
<li>volatile关键字:在开发过程中如果我们为了同步几个实体域就使用synchronized关键字的话，那就开销太大了而volatile关键字为实体域提供了免锁机制。当一个实体域更新了数据之后其他的线程都会看到这个更新(可见性),同时被volatile修饰的实体不能被重排序(保证有序性).<br>volatile在多线程开发中能够保证程序的可见性，有序性但是不保证原子性,因此使用 volatile修饰的实体域不能做自增，自减操作只能做赋值操作.因为原子性的操作在cpu中会被分为好几个步骤执行因此在多线程中有可能当前的线程失去了cpu的控制权导致数据只执行了一半.</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列是支持两个附加操作的队列,当队列为空时，获取元素的线程就会阻塞，直到队列中有数据被添加进来，当队列数据满了时，插入元素的线程就会阻塞，直到队列中有空位置可以使用。<br>Java中的阻塞队列有7种:</p>
<ul>
<li>ArrayBlockingQueue:由数组结构组成的有界阻塞队列.</li>
<li>LinkedBlockingQueue:由链表组成的有界阻塞队列.(当不指定队列大小时，默认为MAX_VALUE)</li>
<li>PriorityBlockingQueue:支持优先级排序的无解阻塞队列。</li>
<li>DelayQueue:使用优先级实现的无界阻塞队列.</li>
<li>SynchronousQueue:不存储元素的阻塞队列.</li>
<li>LinkedTransferQueue:由链表结构组成的无界阻塞队列.</li>
<li>LinkedBlockingDeque:由链表结构组成的双向阻塞队列.<br>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class BlockQueueThread &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(10);</span><br><span class="line"></span><br><span class="line">        ProductThread productThread &#x3D; new ProductThread(linkedBlockingQueue);</span><br><span class="line">        CustomThread customThread &#x3D; new CustomThread(linkedBlockingQueue);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (i &lt; 5) &#123;</span><br><span class="line">                new Thread(productThread).start();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                new Thread(customThread).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建生产者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class ProductThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue;</span><br><span class="line">        private final Random random;</span><br><span class="line"></span><br><span class="line">        ProductThread(LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue) &#123;</span><br><span class="line">            this.linkedBlockingQueue &#x3D; linkedBlockingQueue;</span><br><span class="line">            random &#x3D; new Random();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i &#x3D; random.nextInt(100);</span><br><span class="line">                linkedBlockingQueue.put(i);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;向队列插入数据------&quot; + i);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建消费者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static class CustomThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">        CustomThread(LinkedBlockingQueue&lt;Integer&gt; linkedBlockingQueue) &#123;</span><br><span class="line">            this.linkedBlockingQueue &#x3D; linkedBlockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Integer take &#x3D; linkedBlockingQueue.take();</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;向队列取出数据------&quot; + take);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在编程过程中如果我们在程序中每次都需要开启一个线程执行任务，那么势必会造成系统资源的消耗浪费，所以就有了线程池。线程池的作用就是当我们开启了一个线程任务后将这个线程放入线程池中统一管理，当当前线程处理完任务后不会被销毁而是重用当前线程.<br>创建线程池最好是使用ThreadPoolExecutor这个方法.FixedThreadPool和SingleThreadPool:允许请求的队列长度为interger.MAX_VALUE，可能会堆积大量的请求，导致OOM<br>CacheThreadPool和ScheduledThreadPool:允许创建的线程数量为MAX_VALUE,可能会创建大量的线程,从而导致OOM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看上面代码ThreadPoolExecutor的几个构造方法其中做多的一共需要传入6个参数。这些参数分别为：</p>
<ul>
<li>corePoolSize:核心线程数。默认情况下线程池是空的，只有提交任务时才会创建线程，如果当前运行的线程数少于或等于corePoolSize就不会在创建核心线程。</li>
<li>maximumPoolSize:线程池允许创建的最大线程数。如果任务队列已经满了，并且当前线程数也大于corePoolSize小于maximumPoolSize，则线程会创建新的线程执行任务。</li>
<li>keepAliveTime:非核心线程闲置的时间，当超过这个时候就会回收。</li>
<li>unit:keepAliveTime的时间单位。</li>
<li>BlockingQueue<Runnable>:阻塞队列。如果当前线程数大于corePoolSize就将任务添加到此队列中。</li>
<li>ThreadFactory:线程工厂</li>
<li>RejectedExecutionHandler:饱和策略。当线程池和任务队列都满了时表示无法处理新任务抛出异常。</li>
</ul>
<h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><ul>
<li>Thread是一个类，Runnable是一个接口。</li>
<li>Thread类相对独立不适合多线程资源共享.而Runnable的代码可以被多个线程共享适用于多个线程处理同一资源的情况。</li>
<li>在Runable中虽然可以多个线程进行资源共享但是会存在线程安全问题，所以我们需要在代码中加入锁机制(互斥锁)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ticket implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int ticket &#x3D; 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (ticket.class) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                if (ticket &gt; 0) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;ticket &#x3D; &quot; + ticket--);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ticket ticket &#x3D; new ticket();</span><br><span class="line">new Thread(ticket).start();</span><br><span class="line">new Thread(ticket).start();</span><br><span class="line">new Thread(ticket).start();</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/23/2019-5-23-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" data-id="ck8tr9s7l002hn29kgzeqfpzr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-20-多线程中Future和FutureTask的区别和联系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/" class="article-date">
  <time datetime="2019-05-19T16:00:00.000Z" itemprop="datePublished">2019-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/">多线程中Future和FutureTask的区别和联系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java多线程中我们开启一个线程主要是通过继承Thread类或者实现Runnable接口的方式,但是这两种方式都无法返回线程的执行结果。于是就设计了Future和FutureTask<br>使用Future和FutureTask开启线程需要用到Callable这个接口。<br>Callable的接口定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throw Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出Callable可以返回一个V。</p>
<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future<V>接口</h2><p>Futuer接口是用于获取一个线程执行的结果，对执行的结果进行获取(get)，取消(cancle),判断是否完成等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancle(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get();</span><br><span class="line">    V get(long timeout,TimeUnit unit);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">* V get():获取异步执行的结果，如果没有执行的结果，此方法会阻塞知道异步计算完成。</span><br><span class="line">* V get(long timeout,TimeUnit unit):此方法也是获取异步的执行结果，只不过会有时间限制当超过时间限制时就会抛出异常。</span><br><span class="line">* isDone():任务执行结束,无论是正常结束还是异常取消或者发生异常,都会返回true。</span><br><span class="line">* isCnacelled():任务是否被取消，如果任务在完成前取消则返回true。</span><br><span class="line">* cancle():如果任务还没开始执行取消则返回false，如果任务已经启动执行cancle（true）则任务会以中断的方式试图停止任务，如果停止成功则返回true；当任务已经启动，执行cancle（false）方法将不会对正在执行的任务产生影响，此时返回false；当任务已经完成执行cancle方法将返回false。</span><br><span class="line"></span><br><span class="line">## FutureTask类</span><br><span class="line">FutureTask实现了Future&lt;V&gt;:</span><br></pre></td></tr></table></figure>
<p>public class FutureTask<V> implements RunnableFuture<V> {}</p>
<p>public interface RunnableFuture<V> extends Runnable,Future<V> {}</p>
<pre><code></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/20/2019-5-20-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADFuture%E5%92%8CFutureTask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/" data-id="ck8tr9s7k002en29k7zbs0fgf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-5-13-CountDownLatch的使用场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" class="article-date">
  <time datetime="2019-05-12T16:00:00.000Z" itemprop="datePublished">2019-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">CountDownLatch的使用场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>countdownlatch能够使一个和多个线程处于等待状态直到其他线程执行完再执行。countdownlatch是通过一个计数器来实现的当一个线程完成后count就会减1,直到计数器为0所有的线程都完成了任务，它的闭锁线程才恢复执行。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class CountDoneLatch &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;1&quot;)).start();</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;2&quot;)).start();</span><br><span class="line">        new Thread(new Worker(countDownLatch, &quot;3&quot;)).start();</span><br><span class="line">        new Thread(new Boss(countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Boss implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private CountDownLatch countDoneLatch;</span><br><span class="line"></span><br><span class="line">        Boss(CountDownLatch countDoneLatch) &#123;</span><br><span class="line">            this.countDoneLatch &#x3D; countDoneLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;boss is check work down...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                countDoneLatch.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;boss is checked ok&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Worker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private final CountDownLatch countDownLatch;</span><br><span class="line">        private final String name;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch countDownLatch, String name) &#123;</span><br><span class="line"></span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;worker&quot; + name + &quot;  work down!&quot;);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/05/13/2019-5-13-CountDownLatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/" data-id="ck8tr9s7j002cn29ka2feg80m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="tag">多线程编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-4-27-Bitmap位图优化处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2019-04-26T16:00:00.000Z" itemprop="datePublished">2019-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/">Bitmap位图优化处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android中由于Bitmap位图在加载的时候需要很大的内存开销，容易造成程序OOM。因此系统提供了不同的方式解决Bitmap加载问题.</p>
<h2 id="计算Bitmap的尺寸"><a href="#计算Bitmap的尺寸" class="headerlink" title="计算Bitmap的尺寸"></a>计算Bitmap的尺寸</h2><p>加载位图的方式可以通过decodeByteArray(),decodeFile(),decodeResource()等等。这样的加载方式很容易导致OOM异常。每种类型的加载可以通过BitmapFactory.Options类配置解码选项。在解码的过程中可以通过inJustDecodeBounds属性设置true这样在图片只有宽高资源不会加载到内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line">int imageHeight &#x3D; options.outHeight;</span><br><span class="line">int imageWidth &#x3D; options.outWidth;</span><br><span class="line">String imageType &#x3D; options.outMimeType;</span><br></pre></td></tr></table></figure>
<p>这样就已经获取到了图片的尺寸而且资源没有加载到内存，我们就可以操作图片的宽高达到我们规定的大小。我们可以设置自己的采样率大小，将最终计算的值设置给inSimapleSize.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateInSampleSize(</span><br><span class="line">            BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</span><br><span class="line">    &#x2F;&#x2F; Raw height and width of image</span><br><span class="line">    final int height &#x3D; options.outHeight;</span><br><span class="line">    final int width &#x3D; options.outWidth;</span><br><span class="line">    int inSampleSize &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line"></span><br><span class="line">        final int halfHeight &#x3D; height &#x2F; 2;</span><br><span class="line">        final int halfWidth &#x3D; width &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Calculate the largest inSampleSize value that is a power of 2 and keeps both</span><br><span class="line">        &#x2F;&#x2F; height and width larger than the requested height and width.</span><br><span class="line">        while ((halfHeight &#x2F; inSampleSize) &gt;&#x3D; reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth &#x2F; inSampleSize) &gt;&#x3D; reqWidth) &#123;</span><br><span class="line">            inSampleSize *&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置完inSimpleSize之后还需要将inJustDecodeBounds设置为false，因为在这之前图片的资源还没有在内存中，因此现在将图片加载到内存(我们计算后的大小)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,</span><br><span class="line">        int reqWidth, int reqHeight) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; First decode with inJustDecodeBounds&#x3D;true to check dimensions</span><br><span class="line">    final BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate inSampleSize</span><br><span class="line">    options.inSampleSize &#x3D; calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decode bitmap with inSampleSize set</span><br><span class="line">    options.inJustDecodeBounds &#x3D; false;</span><br><span class="line">    return BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));</span><br></pre></td></tr></table></figure>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>当我们在无网络环境或者需要频繁访问一个资源图片的时候就可以将我们的数据先加载进内存缓存中然后等需要的时候在取出来这样可以提高一个图片的访问速度.<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;获取系统运行内存</span><br><span class="line">    final int maxMemory &#x3D; (int) (Runtime.getRuntime().maxMemory() &#x2F; 1024);</span><br><span class="line">    &#x2F;&#x2F;设置缓存大小</span><br><span class="line">    final int cacheSize &#x3D; maxMemory &#x2F; 8;</span><br><span class="line">    lruCache &#x3D; new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected int sizeOf(@NonNull String key, @NonNull Bitmap bitmap) &#123;</span><br><span class="line">            return bitmap.getByteCount() &#x2F; 1024;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">       </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将bitmap设置到缓存中</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">    if (lruCache !&#x3D; null) &#123;</span><br><span class="line">        if (getBitmapFormCache(key) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lruCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;tag&quot;, &quot;图片已经加入缓存了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 从缓存中取出bitmap</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Bitmap getBitmapFormCache(String key) &#123;</span><br><span class="line">    return lruCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>有些时候我们无法保证缓存的数据一直在内存中，例如：当前缓存的应用退到后台被销毁。<br>这个时候就需要磁盘缓存数据,以保证我们的数据减少Bitmap加载次数.磁盘缓存读取数据依然需要在非UI线程中执行，因为我们无法知道当前读取的时长。<br>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">File diskLruCacheDir &#x3D; getDiskLruCacheDir(this);</span><br><span class="line">        try &#123;</span><br><span class="line">            mDiskLruCache &#x3D; DiskLruCache.open(diskLruCacheDir, 1, 1, DISK_CACHE_SIZE);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">private File getDiskLruCacheDir(Context context) &#123;</span><br><span class="line">        final String cachePath &#x3D; Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !isExternalStorageRemovable() ? Objects.requireNonNull(getExternalCacheDir()).getPath() : context.getCacheDir().getPath();</span><br><span class="line">        return new File(cachePath + File.separator + DiskLruCacheActivity.DISK_CACHE_SUBDIR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> try &#123;</span><br><span class="line">                    &#x2F;&#x2F;将bitmap加入硬盘缓存</span><br><span class="line">                    DiskLruCache.Editor edit &#x3D; mDiskLruCache.edit(&quot;100&quot;);</span><br><span class="line">                    OutputStream os &#x3D; edit.newOutputStream(0);</span><br><span class="line">                    URL url &#x3D; new URL(urls);</span><br><span class="line">                    HttpURLConnection urlConnection &#x3D; (HttpURLConnection) url.openConnection();</span><br><span class="line">                    urlConnection.connect();</span><br><span class="line">                    int contentLength &#x3D; urlConnection.getContentLength();</span><br><span class="line">                    BufferedInputStream bis &#x3D; new BufferedInputStream(urlConnection.getInputStream(), contentLength);</span><br><span class="line">                    BufferedOutputStream bos &#x3D; new BufferedOutputStream(os, contentLength);</span><br><span class="line">                    int b;</span><br><span class="line">                    while ((b &#x3D; bis.read()) !&#x3D; -1) &#123;</span><br><span class="line">                        bos.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bos.flush();</span><br><span class="line"></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line"></span><br><span class="line">                    edit.commit();</span><br><span class="line">                    mDiskLruCache.flush();</span><br><span class="line">                &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;   </span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F;获取磁盘缓存中的图片</span><br><span class="line">        try &#123;</span><br><span class="line">            DiskLruCache.Snapshot snapshot &#x3D; mDiskLruCache.get(&quot;100&quot;);</span><br><span class="line">            InputStream inputStream &#x3D; snapshot.getInputStream(0);</span><br><span class="line">            Bitmap bitmap &#x3D; BitmapFactory.decodeStream(inputStream);</span><br><span class="line">            diskCacheIv.setImageBitmap(bitmap);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择合适的Bitmap解码方式"><a href="#选择合适的Bitmap解码方式" class="headerlink" title="选择合适的Bitmap解码方式"></a>选择合适的Bitmap解码方式</h2><p>Android系统中Bitmap解码默认是ARGB_8888，也就是一个像素占用4个字节.<br>我们可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;系统默认是ARGB_8888每个像素占4个字节</span><br><span class="line">options.inPreferredConfig &#x3D; Bitmap.Config.ARGB_4444;</span><br></pre></td></tr></table></figure>
<p>设置成其他的解码方式.</p>
<h2 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h2><p>当Bitmap的加载是在gridView或者RecyclerView这样的列表视图中时，由于我们的Bitmap加载每次都会开启一个线程这样就会造成多线程并发问题.</p>
<h2 id="及时回收Bitmap内存"><a href="#及时回收Bitmap内存" class="headerlink" title="及时回收Bitmap内存"></a>及时回收Bitmap内存</h2><p>处理完Bitmap图片之后要记得回收掉Bitmap释放资源。在Android 2.3.3及以下需要调用recycle()函数，在2.3.3以上GC会自动管理。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(Build.VERSION.SDK-INT&lt;&#x3D;10) &#123;</span><br><span class="line">        bitmap.recycle();</span><br><span class="line">&#125;</span><br><span class="line">bitmap &#x3D; null;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/27/2019-4-27-Bitmap%E4%BD%8D%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/" data-id="ck8tr9s7n002jn29k4pf08yh0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-16-不是市场失灵，而是那啥失灵" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/" class="article-date">
  <time datetime="2019-04-15T16:00:00.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/">不是市场失灵，而是那啥失灵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>不是市场失灵，而是那啥失灵</p>
<p>因为奔驰女车主的维权事件，知名记者王志安起底了4S店的金融服务费乱象。</p>
<p>女车主王倩（化名）的购车经历是这样的：她在买车时计划全款，但是，利之星的销售反复劝她分期，在缴纳了20多万首付、办完贷款之后，销售突然通知她要缴纳15000元的金融服务费。</p>
<p>顺着这个事，王志安去了解了4S店的一些潜规则：</p>
<p>汽车销售原本是暴利行业。早些年，投资一家4S店，快的两三年就可以收回本金。</p>
<p>但最近几年，竞争日趋激烈，收益率在持续下降。随着价格战越来越激烈，汽车销售的毛利率越来越低，许多4S店零利润甚至负利润也会销售，这就是业内熟知的价格倒挂现象。</p>
<p>因为厂商会在年终时根据销售业绩给4S店返点，如果销售业绩上去了，虽然单车销售可能是亏损的，但算上返点依然有得赚。</p>
<p>除此之外，4S店还挖空心思开发其他盈利点，金融服务费、保险抵押金、店内强制搭售保险、高价销售配件，有些品牌还有出库费、牌费等收费项目，就在这一背景下粉墨登场了。</p>
<p>渐渐地，中国的汽车销售行业形成了这么一种通用模式：用不真实的低价吸引顾客进店，然后再谈交易，交易达成过程中，通过其他附加交易赚取利润。</p>
<p>最后，王老师对这种乱象开出了“政府管一管”的唯一药方：</p>
<p>有什么办法改变么？</p>
<p>只有一个办法，</p>
<p>政府对这个日渐混乱的市场强监管。取消不合法的金融服务费，废除强制搭售的店内保险，取消4S店的一切强制搭售。</p>
<p>如此，这个市场才会逐渐回归服务和诚信。</p>
<p>微博上有网友，甚至包括来去之间这样的微博CEO也认为，这件事反应了市场没能奖优罚劣，是市场失灵的明证。</p>
<p>王志安是一位比较专业的调查记者，我们假设他对事实的调查都是对的，但给出的结论和对策却是完全错的。</p>
<p>首先，我们看女车主王倩的遭遇，她在被诱导办理分期买车之后，突然被告知需要另交15000元的金融服务费。</p>
<p>王倩对此事提出两点质疑：第一、这属于消费欺诈，因为事先没人告知她有这笔开支；第二，所谓的服务并不存在，贷款手续是她自己办的。</p>
<p>王倩的表达非常清晰，这个案子体现的并不是自愿交易的市场行为，而是欺诈，是生米煮成熟饭之后的敲竹杠。</p>
<p>假如我们处在一个更为理想的市场环境里，这种情况可能会以什么方式解决呢？在这个环境里，我们会有真正站在消费者立场的消费者权益保护机构，他们将高效动用舆论或者司法资源来解决这个冲突。</p>
<p>这些机构存在的根基，来源于真正维护消费者权益的举动，而不是税收的无条件供养。这些机构也是彼此竞争的，为了赢得消费者的信任，它们不得不以越来越高的效率、越来越低的成本来解决此类冲突。</p>
<p>现实中，正是因为权力在很大程度上垄断了处理此类冲突的事权，才会导致相应组织（比如工商局、消协，它们有竞争对手吗？）效率低下，它们的核心诉求不是真正解决消费者的问题，而是多一事不如少一事。</p>
<p>想想吧，如果王倩只要打一个电话给消协投诉，就能解决她和奔驰之间的冲突，一个买得起奔驰车的人，何苦撕破脸大闹4S店呢？</p>
<p>现实中就有典型的案例，前段时间，为了加强竞争力，某电商平台升级退换货服务，甚至不需要填理由，点下手指，就有专人上门取货。这可不是因为他们老板良心好，而是因为要面对激烈的市场竞争。</p>
<p>人们容易对市场有两个误会：</p>
<p>一是认为市场应该杜绝一切恶行，如果出现了不完美的情况，那就是市场失灵。实际上，市场只是一种最高效、最经济的选择。再自由的市场，一样会有恶人存在，但市场可以用更低的成本解决或者改善这些问题。完美的世界，只存在于想象中的天国。</p>
<p>第二个误会是，以王倩的案子为例，很多人认为市场的参与主体就是王倩和利之星4S店。西安利之星把王倩欺负成这样，那就是市场失灵了。实际上，市场主体可以是每一个人和机构，王倩的案子是怎么解决的？是她大闹4S店的视频被传到微博，引发众怒才得到解决的。</p>
<p>在这过程中，每一个关注此事的人，都不同程度地参与其中，包括王志安。王志安做这个调查报告，也许不能从王倩身上获得什么直接收益，但收获了粉丝和关注度吧？再次加强了良心大V的人设吧？</p>
<p>感谢市场带来的媒体大发展吧，如果时间回到十几年前，没有自媒体的时代，这位女士就算哭死了也未必有人能帮她。</p>
<p>西安奔驰这个案子的本质是什么呢？是政府（当地工商局、消协）失灵了，王倩不得不撕破脸皮放手一搏，巧妙地撬动了其他市场主体（看客、媒体、媒体平台）的力量，解决了这个问题。</p>
<p>至于王志安说的，4S店卖车不赚钱，只能掏空心思通过别的服务赚钱，我作为一个消费者，怎么看就怎么觉得这是好事。难道我们还应该期待回到4S店卖车暴利，一辆车赚你十几万的时代吗？</p>
<p>4S店目前的这种商业模式，不就跟微信让你免费使用，然后通过一些增值服务来赚钱是一个道理吗？</p>
<p>只要提前告知购车过程中将发生的各种费用，消费者能够自由选择即可，是不是捆绑销售根本不重要。我们真正应该反对的，是这个过程中发生的欺诈现象，而不是这种商业模式本身。</p>
<p>如果按王志安给出的药方：</p>
<p>政府对这个日渐混乱的市场强监管。取消不合法的金融服务费，废除强制搭售的店内保险，取消4S店的一切强制搭售。</p>
<p>这个市场在恢复服务和诚信之前（能不能恢复还不知道，但监管成本一定会迅速增长），车辆一定会先恢复昂贵。</p>
<p>最后，我们再看一个市场显灵的例子吧，算是送李想一次免费广告：</p>
<p>对于真正有远见的企业家而言，市场上的任何痛点，都可能成为他们的盈利点，这样的人多了，剩下的商家要么跟进，要么被淘汰，这也是我们对市场的信心所在：</p>
<p>只要让人自由逐利，这个世界只能越来越好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/16/2019-04-16-%E4%B8%8D%E6%98%AF%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5%EF%BC%8C%E8%80%8C%E6%98%AF%E9%82%A3%E5%95%A5%E5%A4%B1%E7%81%B5/" data-id="ck8tr9s6y000xn29k79htf89y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/" rel="tag">仓央嘉措菜</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-01-Android属性动画源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Android属性动画源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android属性动画的用法主要是针对某一个属性设置具体的动画效果。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator</span><br><span class="line">.ofInt(target,propName,values[])</span><br><span class="line">.setInterpolator(LinearInterpolator)</span><br><span class="line">.setEvaluator(IntEvaluator)</span><br><span class="line">.setDuration(500)</span><br><span class="line">.start();</span><br></pre></td></tr></table></figure>
<p>设置动画作用于view，设置它变化的数据，以及插值器和估值器等最后调用start方法执行动画。</p>
<h2 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectAnimator ofInt(Object target, String propertyName, int... values) &#123;</span><br><span class="line">ObjectAnimator anim &#x3D; new ObjectAnimator(target, propertyName);</span><br><span class="line">anim.setIntValues(values);</span><br><span class="line">return anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例中首先调用了ofInt方法设置要变化的数据。在源代码中首先通过ObjectAnimator属性动画的构造方法，传入作用的属性<br>target和propertyName.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private ObjectAnimator(Object target, String propertyName) &#123;</span><br><span class="line">mTarget &#x3D; target;</span><br><span class="line">setPropertyName(propertyName);</span><br><span class="line">&#125;</span><br><span class="line">public void setPropertyName(String propertyName) &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">mPropertyName &#x3D; propertyName;</span><br><span class="line">mInitialized &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法里面主要是讲target和propertyName记录下来赋值给mTarget和mPropertyName。<br>记录完成后调用setIntValues(values);从调用的名称可以看出这个主要是设置我们传入的具体数值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setIntValues(int... values)</span><br><span class="line">setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setIntValues中调用了setValues将上面的propertyName和valuse传入到PropertyValuesHolder的ofInt中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static PropertyValuesHolder ofInt(String propertyName, int... values) &#123;</span><br><span class="line">return new IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line">public IntPropertyValuesHolder(String propertyName, int... values) &#123;</span><br><span class="line">mPropertyName &#x3D; propertyName;</span><br><span class="line">setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void setIntValues(int... values) &#123;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">mKeyframeSet &#x3D; KeyframeSet.ofInt(values);</span><br><span class="line">mIntKeyframeSet &#x3D; (IntKeyframeSet) mKeyframeSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从PropertyValuesHolder中可以看到将propertyName赋值给了mPropertyName，传出了mValuesType<br>然后还存储了mIntKeyframeSet，从字面意思看是关键帧。这里的mKeyframeSet是由KeyframeSet.ofInt方法获取到的是keyframe的集合，而keyframe叫做关键帧为动画保存time/value对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static KeyframeSet ofInt(int... values) &#123;</span><br><span class="line">int numKeyframes &#x3D; values.length;</span><br><span class="line">IntKeyframe keyframes[] &#x3D; new IntKeyframe[Math.max(numKeyframes,2)];</span><br><span class="line">if (numKeyframes &#x3D;&#x3D; 1) &#123;</span><br><span class="line">keyframes[0] &#x3D; (IntKeyframe) Keyframe.ofInt(0f);</span><br><span class="line">keyframes[1] &#x3D; (IntKeyframe) Keyframe.ofInt(1f, values[0]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">return new IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br><span class="line">public IntKeyframeSet(IntKeyframe... keyframes) &#123;</span><br><span class="line">mNumKeyframes &#x3D; keyframes.length;</span><br><span class="line">mKeyframes &#x3D; new ArrayList&lt;Keyframe&gt;();</span><br><span class="line">mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">mFirstKeyframe &#x3D; mKeyframes.get(0);</span><br><span class="line">mLastKeyframe &#x3D; mKeyframes.get(mNumKeyframes - 1);</span><br><span class="line">mInterpolator &#x3D; mLastKeyframe.getInterpolator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先根据values的长度设置一个keyframes数组，由于我们这里之传入了一个values，所以这个keyframes的长度就是2.然后通过keyframe的ofInt方法去构造keyframe对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IntKeyframe(float fraction, int value) &#123;</span><br><span class="line">mFraction &#x3D; fraction;</span><br><span class="line">mValue &#x3D; value;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">mHasValue &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">IntKeyframe(float fraction) &#123;</span><br><span class="line">mFraction &#x3D; fraction;</span><br><span class="line">mValueType &#x3D; int.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只是对fraction和value进行了赋值操作。然后拿到keyframes数组后调用了IntKeyframeSet方法。<br>初始化IntKeyframeSet内的一些成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public IntKeyframeSet(IntKeyframe... keyframes) &#123;</span><br><span class="line">mNumKeyframes &#x3D; keyframes.length;</span><br><span class="line">mKeyframes &#x3D; new ArrayList&lt;Keyframe&gt;();</span><br><span class="line">mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">mFirstKeyframe &#x3D; mKeyframes.get(0);</span><br><span class="line">mLastKeyframe &#x3D; mKeyframes.get(mNumKeyframes - 1);</span><br><span class="line">mInterpolator &#x3D; mLastKeyframe.getInterpolator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后最终返回了PropertyValuesHolder.ofInt，最终将target，keyframe，valueType交给了setValues中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void setValues(PropertyValuesHolder... values) &#123;</span><br><span class="line">int numValues &#x3D; values.length;</span><br><span class="line">mValues &#x3D; values;</span><br><span class="line">mValuesMap &#x3D; new HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">PropertyValuesHolder valuesHolder &#x3D; values[i];</span><br><span class="line">mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终将PropertyValuesHolder的values，然后通过一个mValuesMap记录以key为属性名称，值为PropertyValuesHolder。</p>
<h2 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setInterpolator(TimeInterpolator value) &#123;</span><br><span class="line">if (value !&#x3D; null) &#123;</span><br><span class="line">mInterpolator &#x3D; value;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mInterpolator &#x3D; new LinearInterpolator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这主要就是记录一下插值器，从源码可以看出<strong>默认是线性的插值器</strong>。</p>
<h2 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setEvaluator(TypeEval    uator value) &#123;</span><br><span class="line">if (value !&#x3D; null &amp;&amp; mValues !&#x3D; null &amp;&amp; mValues.length &gt; 0) &#123;</span><br><span class="line">mValues[0].setEvaluator(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其中有个mValues就是在ofInt中初始化的PropertyValuesHolder。然后调用PropertyValuesHolder.setEvalutor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setEvaluator(TypeEvaluator evaluator) &#123;</span><br><span class="line">mEvaluator &#x3D; evaluator;</span><br><span class="line">mKeyframeSet.setEvaluator(evaluator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是记录一下设置的估值器然后将估值器传入mKeyframeSet中。</p>
<h2 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private long mDuration &#x3D; (long)(300 * sDurationScale);</span><br><span class="line">private long mUnscaledDuration &#x3D; 300;</span><br><span class="line">private static float sDurationScale &#x3D; 1.0f;</span><br><span class="line">public ObjectAnimator setDuration(long duration) &#123;</span><br><span class="line">if (duration &lt; 0) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Animators cannot have negative duration: &quot; +</span><br><span class="line">duration);</span><br><span class="line">&#125;</span><br><span class="line">mUnscaledDuration &#x3D; duration;</span><br><span class="line">mDuration &#x3D; (long)(duration * sDurationScale);</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置动画的执行时间。<br>keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value(这个是我们要传入的真正的数值) , hasValue）。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>设置完动画的所有参数后,接下来就到了最关键的start方法了，在这里执行动画的操作 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">super.start();</span><br><span class="line">&#125;</span><br><span class="line">ValueAnimator</span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">start(false);</span><br><span class="line">&#125;</span><br><span class="line">ValueAnimator</span><br><span class="line">private void start(boolean playBackwards) &#123;</span><br><span class="line">if (Looper.myLooper() &#x3D;&#x3D; null) &#123;</span><br><span class="line">throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mPlayingBackwards &#x3D; playBackwards;</span><br><span class="line">mCurrentIteration &#x3D; 0;</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mStarted &#x3D; true;</span><br><span class="line">mStartedDelay &#x3D; false;</span><br><span class="line">mPaused &#x3D; false;</span><br><span class="line">AnimationHandler animationHandler &#x3D; getOrCreateAnimationHandler();</span><br><span class="line">animationHandler.mPendingAnimations.add(this);</span><br><span class="line">if (mStartDelay &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; This sets the initial value of the animation, prior to actually starting it running</span><br><span class="line">setCurrentPlayTime(0);</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mRunning &#x3D; true;</span><br><span class="line">notifyStartListeners();</span><br><span class="line">&#125;</span><br><span class="line">animationHandler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终从ObjectAnimator的start执行到了ValueAnimator的 start方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mPlayingBackwards &#x3D; playBackwards;</span><br><span class="line">mCurrentIteration &#x3D; 0;</span><br><span class="line">mPlayingState &#x3D; STOPPED;</span><br><span class="line">mStarted &#x3D; true;</span><br><span class="line">mStartedDelay &#x3D; false;</span><br><span class="line">mPaused &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>这里主要是设置动画的一些标记位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimationHandler animationHandler &#x3D; getOrCreateAnimationHandler();</span><br><span class="line">animationHandler.mPendingAnimations.add(this);</span><br></pre></td></tr></table></figure>
<p>这里主要是生成一个AnimationHandler对象这里主要是存储各种状态的valueAnimator。</p>
<h2 id="setCurrentPlayTime"><a href="#setCurrentPlayTime" class="headerlink" title="setCurrentPlayTime"></a>setCurrentPlayTime</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void setCurrentPlayTime(long playTime) &#123;</span><br><span class="line">        initAnimation();</span><br><span class="line">        long currentTime &#x3D; AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">        if (mPlayingState !&#x3D; RUNNING) &#123;</span><br><span class="line">            mSeekTime &#x3D; playTime;</span><br><span class="line">            mPlayingState &#x3D; SEEKED;</span><br><span class="line">        &#125;</span><br><span class="line">        mStartTime &#x3D; currentTime - playTime;</span><br><span class="line">        doAnimationFrame(currentTime);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>首先调用initAnimation初始化动画，然后调用 系统的现在时间currentTime，然后把mPlayingState设置为SEEKED状态，最后调用doAnimationFrame方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void initAnimation() &#123;</span><br><span class="line">        if (!mInitialized) &#123;</span><br><span class="line">            int numValues &#x3D; mValues.length;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">                mValues[i].init();</span><br><span class="line">            &#125;</span><br><span class="line">            mInitialized &#x3D; true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是设置我们 IntPropertyValueHolder的mEvaluator。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PropertyValueHolder的init方法</span><br><span class="line">void init() &#123;</span><br><span class="line">        if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We already handle int and float automatically, but not their Object</span><br><span class="line">            &#x2F;&#x2F; equivalents</span><br><span class="line">            mEvaluator &#x3D; (mValueType &#x3D;&#x3D; Integer.class) ? sIntEvaluator :</span><br><span class="line">                    (mValueType &#x3D;&#x3D; Float.class) ? sFloatEvaluator :</span><br><span class="line">                    null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mEvaluator !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; KeyframeSet knows how to evaluate the common types - only give it a custom</span><br><span class="line">            &#x2F;&#x2F; evaluator if one has been set on this class</span><br><span class="line">            mKeyframeSet.setEvaluator(mEvaluator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置IntPropertyValueHolder的mEvaluator的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final boolean doAnimationFrame(long frameTime) &#123;</span><br><span class="line">        </span><br><span class="line">        final long currentTime &#x3D; Math.max(frameTime, mStartTime);</span><br><span class="line">        return animationFrame(currentTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了animationFrame</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean animationFrame(long currentTime) &#123;</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        switch (mPlayingState) &#123;</span><br><span class="line">        case RUNNING:</span><br><span class="line">        case SEEKED:</span><br><span class="line">            float fraction &#x3D; mDuration &gt; 0 ? (float)(currentTime - mStartTime) &#x2F; mDuration : 1f;</span><br><span class="line">            if (fraction &gt;&#x3D; 1f) &#123;</span><br><span class="line">               &#x2F;&#x2F;...</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPlayingBackwards) &#123;</span><br><span class="line">                fraction &#x3D; 1f - fraction;</span><br><span class="line">            &#125;</span><br><span class="line">            animateValue(fraction);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return done;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据上面 代码中设置的动画执行 状态判断 执行到SEEKED。设置动画执行的fraction<br>然后执行了animaeValue方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void animateValue(float fraction) &#123;</span><br><span class="line">        fraction &#x3D; mInterpolator.getInterpolation(fraction);</span><br><span class="line">        mCurrentFraction &#x3D; fraction;</span><br><span class="line">        int numValues &#x3D; mValues.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].calculateValue(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mUpdateListeners !&#x3D; null) &#123;</span><br><span class="line">            int numListeners &#x3D; mUpdateListeners.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                mUpdateListeners.get(i).onAnimationUpdate(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       int numValues &#x3D; mValues.length;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].setAnimatedValue(mTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里传入我们计算的fraction获取插值器处理后的fraction。<br>接下来执行 mValues[i].calculateValue(fraction)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void calculateValue(float fraction) &#123;</span><br><span class="line">mAnimatedValue &#x3D; mKeyframeSet.getValue(fraction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部又调用了getValue方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Object getValue(float fraction) &#123;</span><br><span class="line">        return getIntValue(fraction);</span><br><span class="line">    &#125;</span><br><span class="line">public int getIntValue(float fraction) &#123;</span><br><span class="line">        if (mNumKeyframes &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (firstTime) &#123;</span><br><span class="line">                firstTime &#x3D; false;</span><br><span class="line">                firstValue &#x3D; ((IntKeyframe) mKeyframes.get(0)).getIntValue();</span><br><span class="line">                lastValue &#x3D; ((IntKeyframe) mKeyframes.get(1)).getIntValue();</span><br><span class="line">                deltaValue &#x3D; lastValue - firstValue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mInterpolator !&#x3D; null) &#123;</span><br><span class="line">                fraction &#x3D; mInterpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return firstValue + (int)(fraction * deltaValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;...省略了很多代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个里面就是调用估值算法通过fraction的值设置动画每一帧执行多少，然后for循环拿到所有的动画执行的百分比计算的数值后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mEvaluator &#x3D;&#x3D; null) &#123;</span><br><span class="line">               return firstValue + (int)(fraction * deltaValue);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>最终给了 IntPropertyValueHolder的 mIntAnimatedValue属性。<br>接下来调用 mValues[i].setAnimatedValue(mTarget);计算后的值通过反射将其设置到set中。<br>最终调用了animationHandler的start方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">private void scheduleAnimation() &#123;</span><br><span class="line">            if (!mAnimationScheduled) &#123;</span><br><span class="line">                mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);</span><br><span class="line">                mAnimationScheduled &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>根据运行时间继续调用doAnimationFrame方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/04/01/2019-04-01-Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="ck8tr9s6x000vn29k0cp0f6ka" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-03-14-Android Service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/14/2019-03-14-Android%20Service/" class="article-date">
  <time datetime="2019-03-13T16:00:00.000Z" itemprop="datePublished">2019-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/14/2019-03-14-Android%20Service/">Android Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>service是一个可以在后台长时间运行的组件，并且没有用户界面.任何一个组件都可以吊起service。同时服务还可以绑定在其他组件中与其进行交互。日常中我们的网络，音乐以及文件I/O都可以在服务中执行。<strong>但是所有的服务都运行在主线程中，因此虽然service可以长时间运行在后台但是自身并不能执行长时间的阻塞主线程的活动，只能开启线程执行。</strong><br>service的启动分为两种：<br>1.调用startServie()启动。这种操作一般是在后台执行单一任务执行完就结束，不会与客户端进行交互。<br>2.bindService()启动。这种操作一般是需要与客户端进行交互的启动方式，在服务中执行长时间的耗时操作然后将结果传给客户端。</p>
<h2 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h2><p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author joshuayingwhat</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BaseService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onCreate启动了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onStartCommand执行了&quot;);</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onDestroy执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">启动:</span><br><span class="line">Intent serviceIntent &#x3D; new Intent(this, BaseService.class);</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>
<p>当调用startService启动服务时服务将一直处于运行状态，调用stopSelf或者stopService停止。<br>当内存不足时系统才会强制停止服务，如果服务已经绑定到Activity上这个时候服务一般是不太会被系统杀死。前台服务是永远都不回被系统杀死的。只有当服务已经启动并且长时间运行在后台这个时候服务才会被系统杀死,一旦资源变得再次可用系统便会重启服务(主要受启动模式的影响)。</p>
<h2 id="bind服务"><a href="#bind服务" class="headerlink" title="bind服务"></a>bind服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.example.androidservice;</span><br><span class="line"></span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Binder;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author joshuayingwhat</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BaseService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    public BaseBinder baseBinder &#x3D; new BaseBinder();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onCreate启动了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onStartCommand执行了&quot;);</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class BaseBinder extends Binder &#123;</span><br><span class="line">        public int getCount() &#123;</span><br><span class="line">            return 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return baseBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        Log.e(&quot;service&quot;, &quot;onDestroy执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private ServiceConnection serviceConnection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            BaseService.BaseBinder serviceBinder &#x3D; (BaseService.BaseBinder) service;</span><br><span class="line">            int count &#x3D; serviceBinder.getCount();</span><br><span class="line">            Log.e(&quot;service&quot;, &quot;绑定的值:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">启动:</span><br><span class="line">Intent serviceIntent &#x3D; new Intent(this, BaseService.class);</span><br><span class="line">bindService(serviceIntent, serviceConnection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>绑定服务的方式有很多种:<br>1.调用服务的onBind方法:如果当前客户端要与服务端进行交互就需要调用这个方法。当我们不需要进行多进程处理的时候就可以调用这个方法进行操作。<br>2.Messenger:当程序需要多进程处理事务的时候，可以在服务中调用Messenger方法.<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.example.androidservice;</span><br><span class="line"></span><br><span class="line">import android.annotation.SuppressLint;</span><br><span class="line">import android.app.Service;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.os.Messenger;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author joshuayingwhat</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BindService extends Service &#123;</span><br><span class="line">    public static final int MSG_WHAT &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    class mHandler extends Handler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MSG_WHAT:</span><br><span class="line">                    int arg1 &#x3D; msg.arg1;</span><br><span class="line">                    Log.e(&quot;TAG&quot;, &quot;建立连接了---&quot; + arg1);</span><br><span class="line">                    Message msgs &#x3D; new Message();</span><br><span class="line">                    msgs.arg1 &#x3D; 10000+arg1;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        msg.replyTo.send(msgs);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    super.handleMessage(msg);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Messenger sMessage &#x3D; new Messenger(new mHandler());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return sMessage.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    public Messenger messengerclient &#x3D; new Messenger(new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            int arg1 &#x3D; msg.arg1;</span><br><span class="line">            Log.e(&quot;TAG&quot;, &quot;服务器返回的数据-------&quot; + arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">Intent serviceIntent &#x3D; new Intent(this, BindService.class);</span><br><span class="line">bindService(serviceIntent, serviceConnection, BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">    private ServiceConnection serviceConnection &#x3D; new ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            Messenger messenger &#x3D; new Messenger(service);</span><br><span class="line">            Message msg &#x3D; new Message();</span><br><span class="line">            msg.arg1 &#x3D; 200;</span><br><span class="line">            msg.replyTo &#x3D; messengerclient;</span><br><span class="line">            msg.what &#x3D; BindService.MSG_WHAT;</span><br><span class="line">            try &#123;</span><br><span class="line">                messenger.send(msg);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="前台运行服务"><a href="#前台运行服务" class="headerlink" title="前台运行服务"></a>前台运行服务</h2><p>前台服务是一种用户感知的服务，它不会被系统杀死。它是以一种状态栏的形式被创建.<br>例如:音乐播放器<br>通过调用startForeground就可以启动前台服务了.<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Notification notification &#x3D; new Notification(R.drawable.icon, getText(R.string.ticker_text),</span><br><span class="line">        System.currentTimeMillis());</span><br><span class="line">Intent notificationIntent &#x3D; new Intent(this, ExampleActivity.class);</span><br><span class="line">PendingIntent pendingIntent &#x3D; PendingIntent.getActivity(this, 0, notificationIntent, 0);</span><br><span class="line">notification.setLatestEventInfo(this, getText(R.string.notification_title),</span><br><span class="line">        getText(R.string.notification_message), pendingIntent);</span><br><span class="line">startForeground(ONGOING_NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure>
<p>在结束的时候停止当前这个前台服务时调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopForeground(ONGOING_NOTIFICATION_ID)</span><br></pre></td></tr></table></figure>

<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是Service的子类，它可以处理对与服务有多个请求的事件。内部通过一个工作队列处理对多个线程的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.example.androidservice;</span><br><span class="line"></span><br><span class="line">import android.app.IntentService;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author joshuayingwhat</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BaseIntentService extends IntentService &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;base_intent_service&quot;;</span><br><span class="line"></span><br><span class="line">    private static Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public static final int HANDLER_WHAT &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Creates an IntentService.  Invoked by your subclass&#39;s constructor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void setUiHandler(Handler mUiHandler) &#123;</span><br><span class="line">        mHandler &#x3D; mUiHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseIntentService() &#123;</span><br><span class="line">        super(TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onHandleIntent(@Nullable Intent intent) &#123;</span><br><span class="line">        String numberInteger &#x3D; intent.getExtras().getString(MainActivity.NUMBER_INTEGER);</span><br><span class="line">        setUiData(mHandler, numberInteger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setUiData(Handler mHandler, String numberInteger) &#123;</span><br><span class="line">        Message msg &#x3D; mHandler.obtainMessage();</span><br><span class="line">        msg.obj &#x3D; numberInteger;</span><br><span class="line">        msg.what &#x3D; HANDLER_WHAT;</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BaseIntentService.setUiHandler(new Handler(this));</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case BaseIntentService.HANDLER_WHAT:</span><br><span class="line">                String number &#x3D; (String) msg.obj;</span><br><span class="line">                Log.e(&quot;TAG&quot;, &quot;----------&quot; + number);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/03/14/2019-03-14-Android%20Service/" data-id="ck8tr9s720016n29k5uwnee8r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-03-10-Fragment常见问题分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/2019-03-10-Fragment%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-03-09T16:00:00.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/2019-03-10-Fragment%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Fragment常见问题分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="getActivity空指针异常"><a href="#getActivity空指针异常" class="headerlink" title="getActivity空指针异常"></a>getActivity空指针异常</h2><p>有些时候当我们调用getActivity的时候会出现空指针异常的情况，例如：在“内存重启”(这个可以理解为屏幕旋转的时候)或者Frgment中有一些耗时较长的任务还在执行的时候此时  Fragment已经Detach了Activity所以getActivity会报空指针异常.<br>解决方法为:<br>    在Fragment基类里设置一个Activity mActivity的全局变量,在onAttach方法中赋值使用mActivity取代getActivity.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onAttach(@NonNull Context context) &#123;</span><br><span class="line">        super.onAttach(context);</span><br><span class="line">        mActivity &#x3D; (Activity) context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常：Can-not-perform-this-action-after-onSaveInstanceState"><a href="#异常：Can-not-perform-this-action-after-onSaveInstanceState" class="headerlink" title="异常：Can not perform this action after onSaveInstanceState"></a>异常：Can not perform this action after onSaveInstanceState</h2><p>产生这个异常的原因就是当出现意外情况时宿主Activity已经onStop了这个时候如果我们执行Fragment的事务的话就会报这个异常，因为当我们的Activity被stop之后系统就会执行onSaveInstanceState方法保存当前Activity的所有状态。又因为Fragment的事务是在onStop之后调用的当前Activity没有保存状态。<br>解决方法:<br>  1.调用commitAllowingStateLoss方法，但是事务有可能提交不成功.</p>
<h2 id="Fragment重叠问题"><a href="#Fragment重叠问题" class="headerlink" title="Fragment重叠问题"></a>Fragment重叠问题</h2><p>当宿主Activity将被kill或者旋转屏幕或者内存泄漏时系统就会调用onSaveInstanceState方法保存当前Activity状态,所以Fragmnt的状态也将会被保存下来又因为系统没有将Fragment的显示或者隐藏状态保存，Fragment默认状态为show()因此就发生了重叠。<br>解决方法:<br>在基类Fragment中我们可以自己记录Fragment的显示和隐藏状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BaseFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    private static final String STATE_SAVE_IS_HIDDEN &#x3D; &quot;STATE_SAVE_IS_HIDDEN&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        if (savedInstanceState !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">            boolean aBoolean &#x3D; savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN);</span><br><span class="line">            FragmentTransaction transaction &#x3D; getFragmentManager().beginTransaction();</span><br><span class="line">            if (aBoolean) &#123;</span><br><span class="line">                transaction.hide(this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                transaction.show(this);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSaveInstanceState(@NonNull Bundle outState) &#123;</span><br><span class="line">        super.onSaveInstanceState(outState);</span><br><span class="line">        outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时如果还发生重叠现象那是因为在根Fragemnt中没有对状态做判断.</p>
<h2 id="Fragment中startActivityForResult与getActivity-startActivityForResult的区别"><a href="#Fragment中startActivityForResult与getActivity-startActivityForResult的区别" class="headerlink" title="Fragment中startActivityForResult与getActivity().startActivityForResult的区别"></a>Fragment中startActivityForResult与getActivity().startActivityForResult的区别</h2><p>在Frgment中有些时候我们启动一个Activity时调用startActivityForResult()方法获取返回结果有些时候requestCode总有对应不上的情况.<br>示例:<br>startActivityForResult:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-03-10 10:45:10.768 14193-14193&#x2F;com.example.myapplication E&#x2F;tag: 这是未添加getActivity的方式 MyFragment requestCode:1</span><br><span class="line">2019-03-10 10:45:10.768 14193-14193&#x2F;com.example.myapplication E&#x2F;tag: 这是未添加getActivity的方式 MainActivity  requestCode:65537</span><br></pre></td></tr></table></figure>

<p>getActivity().startActivityForResult:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-03-10 10:47:50.154 14426-14426&#x2F;com.example.myapplication E&#x2F;tag: 这是getActivity的方式 MainActivity  requestCode:1</span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看出当我们调用startActivityForResult方法时Fragment中的onActivityResult获取到的结果是一致的，但是Activity中获取到的值要大于65535.通过调用getActivity().startActivityForResult时只有MainActivity能接收到返回结果.</p>
<p><strong>源码分析</strong><br>1.Fragment的startActivityForResult:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode) &#123;</span><br><span class="line">    startActivityForResult(intent, requestCode, null);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">    if (mHost &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Fragment &quot; + this + &quot; not attached to Activity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mHost.onStartActivityFromFragment(this &#x2F;*fragment*&#x2F;, intent, requestCode, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startActivityForResult方法最终调用的是mHost.onStartActivityFromFragment方法。mHost是Fragment中HostCallbacks的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class HostCallbacks extends FragmentHostCallback&lt;FragmentActivity&gt; &#123;</span><br><span class="line">    public HostCallbacks() &#123;</span><br><span class="line">        super(FragmentActivity.this &#x2F;*fragmentActivity*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ....</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onStartActivityFromFragment(</span><br><span class="line">            Fragment fragment, Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        FragmentActivity.this.startActivityFromFragment(fragment, intent, requestCode, options);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用了onStartActivityFromFragment方法，然后执行了FragmentActivity.this.startActivityFromFragment。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Called by Fragment.startActivityForResult() to implement its behavior.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void startActivityFromFragment(Fragment fragment, Intent intent,</span><br><span class="line">                                      int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">    mStartedActivityFromFragment &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 第1步</span><br><span class="line">        if (requestCode &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            ActivityCompat.startActivityForResult(this, intent, -1, options);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 第2步</span><br><span class="line">        checkForValidRequestCode(requestCode);</span><br><span class="line">        &#x2F;&#x2F; 第3步</span><br><span class="line">        int requestIndex &#x3D; allocateRequestIndex(fragment);</span><br><span class="line">	&#x2F;&#x2F; 第4步</span><br><span class="line">        ActivityCompat.startActivityForResult(</span><br><span class="line">                this, intent, ((requestIndex + 1) &lt;&lt; 16) + (requestCode &amp; 0xffff), options);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStartedActivityFromFragment &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步:<br>当requestCode == -1时，这个是调用startActivity的时候执行的。<br>第二步:<br>检查requestCode的合法性。requestCode的取值范围在[0-65535]之间.<br>第三步:<br>获取当前fragment的请求索引值。<br>第四步:<br>调用Activity中的startActivityForResult方法,同时将requestCode方法右移16位。</p>
<p>2.Fragment中的getActivity().startActivityForResult().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Modifies the standard behavior to allow results to be delivered to fragments.</span><br><span class="line"> * This imposes a restriction that requestCode be &lt;&#x3D; 0xffff.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void startActivityForResult(Intent intent, int requestCode) &#123;</span><br><span class="line">    &#x2F;&#x2F; If this was started from a Fragment we&#39;ve already checked the upper 16 bits were not in</span><br><span class="line">    &#x2F;&#x2F; use, and then repurposed them for the Fragment&#39;s index.</span><br><span class="line">    if (!mStartedActivityFromFragment) &#123;</span><br><span class="line">        if (requestCode !&#x3D; -1) &#123;</span><br><span class="line">            checkForValidRequestCode(requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    super.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终执行到了onActivityResult()方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Dispatch incoming result to the correct fragment.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    int requestIndex &#x3D; requestCode&gt;&gt;16;</span><br><span class="line">    if (requestIndex !&#x3D; 0) &#123;</span><br><span class="line">        requestIndex--;</span><br><span class="line"> </span><br><span class="line">        String who &#x3D; mPendingFragmentActivityResults.get(requestIndex);</span><br><span class="line">        mPendingFragmentActivityResults.remove(requestIndex);</span><br><span class="line">        if (who &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Activity result delivered for unknown Fragment.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Fragment targetFragment &#x3D; mFragments.findFragmentByWho(who);</span><br><span class="line">        if (targetFragment &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Activity result no fragment exists for who: &quot; + who);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            targetFragment.onActivityResult(requestCode &amp; 0xffff, resultCode, data);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这里调用了onActivityResult,所以Activity中的onActivityResult方法就会被调用获取到requestCode值但是这个值是已经被改变了的。这里现将requestCode左移16位获取requestIndex的值，如果!=0就获取到目标Fragment然后调用Fragment中的onActivityResult，同时将requestCode还原(requestCode &amp; 0xffff).<br>如果是getActivity调用startActivityForResult时，requestIndex=0就不执行if语句<br>直接执行super.onActivityResult(requestCode, resultCode, data)。</p>
<p>总结:<br>所以当我们在Fragment中如果需要Fragment获取到返回值时，需要调用startActivityForResult。<br>requestCode一定不要大于65535.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/03/10/2019-03-10-Fragment%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" data-id="ck8tr9s70000zn29k1yco7vi9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-02-20-RecyclerView源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/20/2019-02-20-RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-02-19T16:00:00.000Z" itemprop="datePublished">2019-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/20/2019-02-20-RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">RecyclerView源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RecyclerView做为一个可以处理大量数据的控件同时也是日常开发中经常需要用到了的控件所以知道它的内部实现原理对于解决一些常见问题还是非常有帮助的，它的内部就是一个自定义的ViewGroup，<code>public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild2</code>就来看一下它的内部是怎么样自定义这个ViewGroup的，又是怎样处理这些数据和缓存的逻辑等等。</p>
<h2 id="OnMeasure过程"><a href="#OnMeasure过程" class="headerlink" title="OnMeasure过程"></a>OnMeasure过程</h2><p>既然是一个自定义的ViewGroup所以必然会执行onMeasure方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">        final int widthMode &#x3D; MeasureSpec.getMode(widthSpec);</span><br><span class="line">        final int heightMode &#x3D; MeasureSpec.getMode(heightSpec);</span><br><span class="line">        final boolean skipMeasure &#x3D; widthMode &#x3D;&#x3D; MeasureSpec.EXACTLY</span><br><span class="line">                &amp;&amp; heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        if (skipMeasure || mAdapter &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到mLayout调用了onMeasure方法,而这个mLayout就是一个LayoutManager，是RecyclerView的内部类.所以RecyclrView的onMeasure就是交给了LayoutManager处理.<br>在layoutManager中调用了defaultOnMeasure方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void onMeasure(@NonNull RecyclerView.Recycler recycler, @NonNull RecyclerView.State state, int widthSpec, int heightSpec) &#123;</span><br><span class="line">      this.mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以onMeasure方法最后又调用了RecyclerView的defaultOnMeasure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">   int width &#x3D; RecyclerView.LayoutManager.chooseSize(widthSpec, this.getPaddingLeft() + this.getPaddingRight(), ViewCompat.getMinimumWidth(this));</span><br><span class="line">   int height &#x3D; RecyclerView.LayoutManager.chooseSize(heightSpec, this.getPaddingTop() + this.getPaddingBottom(), ViewCompat.getMinimumHeight(this));</span><br><span class="line">   this.setMeasuredDimension(width, height);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最后是在defaultOnMeasure中测量了RecyclerView，调用chooseSize方法获取测量大小和测量模式.<br>回到上面接着就是调用了dispatchLayoutStep2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">  this.startInterceptRequestLayout();</span><br><span class="line">  this.onEnterLayoutOrScroll();</span><br><span class="line">  this.mState.assertLayoutStep(6);</span><br><span class="line">  this.mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">  this.mState.mItemCount &#x3D; this.mAdapter.getItemCount();</span><br><span class="line">  this.mState.mDeletedInvisibleItemCountSincePreviousLayout &#x3D; 0;</span><br><span class="line">  this.mState.mInPreLayout &#x3D; false;</span><br><span class="line">  this.mLayout.onLayoutChildren(this.mRecycler, this.mState);</span><br><span class="line">  this.mState.mStructureChanged &#x3D; false;</span><br><span class="line">  this.mPendingSavedState &#x3D; null;</span><br><span class="line">  this.mState.mRunSimpleAnimations &#x3D; this.mState.mRunSimpleAnimations &amp;&amp; this.mItemAnimator !&#x3D; null;</span><br><span class="line">  this.mState.mLayoutStep &#x3D; 4;</span><br><span class="line">  this.onExitLayoutOrScroll();</span><br><span class="line">  this.stopInterceptRequestLayout(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个里面可以看到有一个this.mLayout.onLayoutChildren的方法,这里就是测量子控件的大小和位置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">    &#x2F;&#x2F; layout algorithm:</span><br><span class="line">    &#x2F;&#x2F; 1) by checking children and other variables, find an anchor coordinate and an anchor</span><br><span class="line">    &#x2F;&#x2F;  item position.</span><br><span class="line">    &#x2F;&#x2F; 2) fill towards start, stacking from bottom</span><br><span class="line">    &#x2F;&#x2F; 3) fill towards end, stacking from top</span><br><span class="line">    &#x2F;&#x2F; 4) scroll to fulfill requirements like stack from bottom.</span><br><span class="line">    ...</span><br><span class="line">    mAnchorInfo.mLayoutFromEnd &#x3D; mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">    &#x2F;&#x2F; calculate anchor position and coordinate</span><br><span class="line">    updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">    ...</span><br><span class="line">    if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; fill towards end</span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra &#x3D; extraForEnd;</span><br><span class="line">        fill(recycler, mLayoutState, state, false);</span><br><span class="line">        endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">        final int lastElement &#x3D; mLayoutState.mCurrentPosition;</span><br><span class="line">        if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">            extraForStart +&#x3D; mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; fill towards start</span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra &#x3D; extraForStart;</span><br><span class="line">        mLayoutState.mCurrentPosition +&#x3D; mLayoutState.mItemDirection;</span><br><span class="line">        fill(recycler, mLayoutState, state, false);</span><br><span class="line">        startOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onLayoutChildren方法中看到了一个fill(填充)方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">        RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int remainingSpace &#x3D; layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult &#x3D; new LayoutChunkResult();</span><br><span class="line">    while (...&amp;&amp;layoutState.hasMore(state)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (...) &#123;</span><br><span class="line">            layoutState.mAvailable -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">            remainingSpace -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">        &#125;</span><br><span class="line">        if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCOLLING_OFFSET_NaN) &#123;</span><br><span class="line">            layoutState.mScrollingOffset +&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">            if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">                layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            recycleByLayoutState(recycler, layoutState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中有一个重要的layoutChunk方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="line">        LayoutState layoutState, LayoutChunkResult result) &#123;</span><br><span class="line">    View view &#x3D; layoutState.next(recycler);</span><br><span class="line">    ...</span><br><span class="line">    if (layoutState.mScrapList &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (mShouldReverseLayout &#x3D;&#x3D; (layoutState.mLayoutDirection</span><br><span class="line">                &#x3D;&#x3D; LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addView(view, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    measureChildWithMargins(view, 0, 0);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; We calculate everything with View&#39;s bounding box (which includes decor and margins)</span><br><span class="line">    &#x2F;&#x2F; To calculate correct layout position, we subtract margins.</span><br><span class="line">    layoutDecorated(view, left + params.leftMargin, top + params.topMargin,</span><br><span class="line">            right - params.rightMargin, bottom - params.bottomMargin);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个里面是真正的执行了获取子View控件并将子View填充到RecyclerView中.layoutState.next方法就是获取adapter中的子控件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View next(Recycler recycler) &#123;</span><br><span class="line">      if(this.mScrapList !&#x3D; null) &#123;</span><br><span class="line">        return this.nextViewFromScrapList();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        View view &#x3D; recycler.getViewForPosition(this.mCurrentPosition);</span><br><span class="line">        this.mCurrentPosition +&#x3D; this.mItemDirection;</span><br><span class="line">        return view;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里然后调用了recycler.getViewForPosition和this.tryGetViewHolderForPositionByDeadline。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">   public View getViewForPosition(int position) &#123;</span><br><span class="line">     return this.getViewForPosition(position, false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">     return this.tryGetViewHolderForPositionByDeadline(position, dryRun, 9223372036854775807L).itemView;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   RecyclerView.ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">           holder &#x3D; RecyclerView.this.mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这里看到了非常熟悉的createViewHolder，这个时候就和Adapter关联起来了.获取到了item的View后就将调用addView将它添加到RecyclerView中.<br>获取完view后接着调用了measureChildWithMargins方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void measureChildWithMargins(@NonNull View child, int widthUsed, int heightUsed) &#123;</span><br><span class="line">      RecyclerView.LayoutParams lp &#x3D; (RecyclerView.LayoutParams)child.getLayoutParams();</span><br><span class="line">      Rect insets &#x3D; this.mRecyclerView.getItemDecorInsetsForChild(child);</span><br><span class="line">      widthUsed +&#x3D; insets.left + insets.right;</span><br><span class="line">      heightUsed +&#x3D; insets.top + insets.bottom;</span><br><span class="line">      int widthSpec &#x3D; getChildMeasureSpec(this.getWidth(), this.getWidthMode(), this.getPaddingLeft() + this.getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, this.canScrollHorizontally());</span><br><span class="line">      int heightSpec &#x3D; getChildMeasureSpec(this.getHeight(), this.getHeightMode(), this.getPaddingTop() + this.getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, this.canScrollVertically());</span><br><span class="line">      if(this.shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;</span><br><span class="line">        child.measure(widthSpec, heightSpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中就是测量每个item的大小和分割线的大小.<br>在onMeasure方法中我们测量了recyclerview的大小和item的大小并将其添加到了recyclerview中.<br>接下来看一下RecyclerView的onLayout方法.</p>
<h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    TraceCompat.beginSection(&quot;RV OnLayout&quot;);</span><br><span class="line">    this.dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    this.mFirstLayoutComplete &#x3D; true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在onLayout中还是调用了dispatchLayout方法，最后还是调用了dispatchLayoutStep2方法.</p>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void draw(Canvas c) &#123;</span><br><span class="line">    super.draw(c);</span><br><span class="line"></span><br><span class="line">    final int count &#x3D; mItemDecorations.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, this, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDraw(Canvas c) &#123;</span><br><span class="line">    super.onDraw(c);</span><br><span class="line"></span><br><span class="line">    final int count &#x3D; mItemDecorations.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, this, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里除了绘制自身以外还绘制了分割线.</p>
<h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><p>RecyclerView的滑动有两个过程，一个是手指在屏幕滑动的过程(scroll)，另一个是手指滑动离开屏幕的过程(fling).<br>RecyclerView的滑动是从onTouchEvent开始.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent e) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mVelocityTracker &#x3D;&#x3D; null) &#123;</span><br><span class="line">        mVelocityTracker &#x3D; VelocityTracker.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            ...</span><br><span class="line">            final int x &#x3D; (int) (MotionEventCompat.getX(e, index) + 0.5f);</span><br><span class="line">            final int y &#x3D; (int) (MotionEventCompat.getY(e, index) + 0.5f);</span><br><span class="line">            int dx &#x3D; mLastTouchX - x;</span><br><span class="line">            int dy &#x3D; mLastTouchY - y;</span><br><span class="line">            ...</span><br><span class="line">            if (mScrollState !&#x3D; SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                ...</span><br><span class="line">                if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                    if (dy &gt; 0) &#123;</span><br><span class="line">                        dy -&#x3D; mTouchSlop;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dy +&#x3D; mTouchSlop;</span><br><span class="line">                    &#125;</span><br><span class="line">                    startScroll &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (startScroll) &#123;</span><br><span class="line">                    setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mScrollState &#x3D;&#x3D; SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                mLastTouchX &#x3D; x - mScrollOffset[0];</span><br><span class="line">                mLastTouchY &#x3D; y - mScrollOffset[1];</span><br><span class="line"></span><br><span class="line">                if (scrollByInternal(</span><br><span class="line">                        canScrollHorizontally ? dx : 0,</span><br><span class="line">                        canScrollVertically ? dy : 0,</span><br><span class="line">                        vtev)) &#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line">        case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            ...</span><br><span class="line">            final float yvel &#x3D; canScrollVertically ?</span><br><span class="line">                    -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;</span><br><span class="line">            if (!((xvel !&#x3D; 0 || yvel !&#x3D; 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</span><br><span class="line">                setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">            &#125;</span><br><span class="line">            resetTouch();</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先确定滑动的偏移量大于系统的滑动值，然后就将滑动状态设置为SCROLL_STATE_DRAGGING，然后执行scrollByInternal()方法，而在这个方法里面最终回去调用LinearLayoutManager.scrollBy()，这是RecyclerView滑动的第一阶段.当手指离开屏幕后MotionEvent.ACTION_UP或者MotionAction.Cancel就会执行，在MotionEvent.ACTION_UP中首先会去计算当前滑动的速度，然后调用fling()方法，在这里就是滑动的第二阶段,然后将滑动状态设置为SCROLL_STATE_IDLE.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean fling(int velocityX, int velocityY) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mViewFlinger.fling(velocityX, velocityY);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在fling方法中，又回执行mViewFlinger，而这个mViewFlinger是一个Runnable对象。它的fling方法实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void postOnAnimation() &#123;</span><br><span class="line">    if (mEatRunOnAnimationRequest) &#123;</span><br><span class="line">        mReSchedulePostAnimationCallback &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        removeCallbacks(this);</span><br><span class="line">        ViewCompat.postOnAnimation(RecyclerView.this, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void fling(int velocityX, int velocityY) &#123;</span><br><span class="line">    setScrollState(SCROLL_STATE_SETTLING);</span><br><span class="line">    mLastFlingX &#x3D; mLastFlingY &#x3D; 0;</span><br><span class="line">    mScroller.fling(0, 0, velocityX, velocityY,</span><br><span class="line">            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    postOnAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里回去调用Scroller的fling方法，然后在postOnAnimation某时刻会去执行我们给定的Runnable对象.<br>mViewFlinger.run()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (scroller.computeScrollOffset()) &#123;</span><br><span class="line">        final int x &#x3D; scroller.getCurrX();</span><br><span class="line">        final int y &#x3D; scroller.getCurrY();</span><br><span class="line">        final int dx &#x3D; x - mLastFlingX;</span><br><span class="line">        final int dy &#x3D; y - mLastFlingY;</span><br><span class="line">        ...</span><br><span class="line">        if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (dy !&#x3D; 0) &#123;</span><br><span class="line">                vresult &#x3D; mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">                overscrollY &#x3D; dy - vresult;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        if (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate();&#x2F;&#x2F;刷新界面</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        if (scroller.isFinished() || !fullyConsumedAny) &#123;</span><br><span class="line">            setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            postOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最后也是调用了mLayout.scrollVerticallyBy方法,最后也是执行到LinearLayoutManager.scrollBy()方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final int absDy &#x3D; Math.abs(dy);</span><br><span class="line">    updateLayoutState(layoutDirection, absDy, true, state);</span><br><span class="line">    final int consumed &#x3D; mLayoutState.mScrollingOffset</span><br><span class="line">            + fill(recycler, mLayoutState, state, false);</span><br><span class="line">    ...</span><br><span class="line">    final int scrolled &#x3D; absDy &gt; consumed ? layoutDirection * consumed : dy;</span><br><span class="line">    mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在LinearLayoutManager.scrollBy()方法中首先会调用fill()方法将我们需要显示并且要填充的item加入进来，然后计算出一个consumed偏移量，最后调用mOrientationHelper.offsetChildren()方法计算出需要的滑动偏移量,也就是平移item.</p>
<h2 id="RecyclerView回收复用之Recycler"><a href="#RecyclerView回收复用之Recycler" class="headerlink" title="RecyclerView回收复用之Recycler"></a>RecyclerView回收复用之Recycler</h2><p>Recycler是RecyclerView的缓存器</p>
<p><code>public final class Recycler {
        final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();
        ArrayList&lt;ViewHolder&gt; mChangedScrap = null;
        final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();
private final List&lt;ViewHolder&gt;
                mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);
        private int mRequestedCacheMax = DEFAULT_CACHE_SIZE;
        int mViewCacheMax = DEFAULT_CACHE_SIZE;
        RecycledViewPool mRecyclerPool;
        private ViewCacheExtension mViewCacheExtension;}</code><br>这个Recycler的作用就是重用itemview，当然重用的item是从它的缓存中获取到。在上面fill方法中有一个layoutChunk方法在这方法中的View view = layoutState.next(recycler);就是获取itemview的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">            boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">           ...</span><br><span class="line">&#x2F;&#x2F; 0) If there is a changed scrap, try to find from there</span><br><span class="line">if (mState.isPreLayout()) &#123;</span><br><span class="line">    holder &#x3D; getChangedScrapViewForPosition(position);</span><br><span class="line">    fromScrap &#x3D; holder !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1) Find from scrap by position</span><br><span class="line">if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">    holder &#x3D; getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 2) Find from scrap via stable ids, if exists</span><br><span class="line">    if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">        holder &#x3D; getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder &#x3D;&#x3D; null &amp;&amp; mViewCacheExtension !&#x3D; null) &#123;</span><br><span class="line">        final View view &#x3D; mViewCacheExtension</span><br><span class="line">                .getViewForPositionAndType(this, position, type);</span><br><span class="line">        if (view !&#x3D; null) &#123;</span><br><span class="line">            holder &#x3D; getChildViewHolder(view);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        holder &#x3D; getRecycledViewPool().getRecycledView(type);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        holder &#x3D; mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">boolean bound &#x3D; false;</span><br><span class="line">if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">    &#x2F;&#x2F; do not update unless we absolutely have to.</span><br><span class="line">    holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">&#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会先从Scrap，Cache，Recycled从找需要的itemview如果没有就会调用mAdapter.createViewHolder方法创建一个itemview方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2019/02/20/2019-02-20-RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ck8tr9s6w000tn29k8gg9gnf5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 17.5px;">Java</a> <a href="/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/" style="font-size: 12.5px;">仓央嘉措菜</a> <a href="/tags/%E5%90%B4%E4%B8%BB%E4%BB%BB%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7/" style="font-size: 15px;">吴主任的公众号</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">多线程编程</a> <a href="/tags/%E8%A4%9A%E6%98%8E%E5%AE%87/" style="font-size: 10px;">褚明宇</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 17.5px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/31/2019-12-31-%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/">软引用和弱引用</a>
          </li>
        
          <li>
            <a href="/2019/12/06/2019-12-06-Android%20TextView%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">Android TextView源代码分析</a>
          </li>
        
          <li>
            <a href="/2019/11/12/2019-11-12-Http%E8%AF%B7%E6%B1%82%E5%A4%B4Cache-Control%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">Http请求头Cache-Control机制详解</a>
          </li>
        
          <li>
            <a href="/2019/11/05/2019-11-05-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E5%92%8C%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3/">什么是子网掩码和默认网关</a>
          </li>
        
          <li>
            <a href="/2019/11/04/2019-11-04-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%86%E9%85%8D%E7%9A%84/">计算机中IP地址是怎样分配的</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 JoshuaYingWhatEgr<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joshuayingwhategr.github.io/2020/10/15/page/3/index/" data-id="ckgafft0w0041cd9k1v2t90ec" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/10/15/page/4/index/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          page/4/index
        
      </div>
    </a>
  
  
    <a href="/2020/10/15/page/2/index/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">page/2/index</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 17.5px;">Java</a> <a href="/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/" style="font-size: 12.5px;">仓央嘉措菜</a> <a href="/tags/%E5%90%B4%E4%B8%BB%E4%BB%BB%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7/" style="font-size: 15px;">吴主任的公众号</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">多线程编程</a> <a href="/tags/%E8%A4%9A%E6%98%8E%E5%AE%87/" style="font-size: 10px;">褚明宇</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 17.5px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/15/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index/">tags/计算机网络/index</a>
          </li>
        
          <li>
            <a href="/2020/10/15/tags/Java/index/">tags/Java/index</a>
          </li>
        
          <li>
            <a href="/2020/10/15/tags/%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E8%8F%9C/index/">tags/仓央嘉措菜/index</a>
          </li>
        
          <li>
            <a href="/2020/10/15/tags/%E5%90%B4%E4%B8%BB%E4%BB%BB%E7%9A%84%E5%85%AC%E4%BC%97%E5%8F%B7/index/">tags/吴主任的公众号/index</a>
          </li>
        
          <li>
            <a href="/2020/10/15/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/index/">tags/多线程编程/index</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 JoshuaYingWhatEgr<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>